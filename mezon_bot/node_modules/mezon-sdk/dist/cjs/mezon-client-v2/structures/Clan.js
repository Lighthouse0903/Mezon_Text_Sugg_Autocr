"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Clan = void 0;
const constants_1 = require("../../constants");
const CacheManager_1 = require("../utils/CacheManager");
const TextChannel_1 = require("./TextChannel");
class Clan {
    constructor(initClanData, client, apiClient, socketManager, sessionToken, messageQueue) {
        // cache status load channel
        this._channelsLoaded = false;
        // cache status load channel call api
        this._loadingPromise = null;
        this.id = initClanData.id;
        this.name = initClanData.name;
        this.client = client;
        this.apiClient = apiClient;
        this.socketManager = socketManager;
        this.messageQueue = messageQueue;
        this.sessionToken = sessionToken;
        this.channels = new CacheManager_1.CacheManager(async (channelId) => {
            return this.client.channels.fetch(channelId);
        });
        this.users = new CacheManager_1.CacheManager(async (user_id) => {
            // TODO: If the channel's user cache is empty,
            // and channel.users.fetch(user_id) is called,
            // this function will be triggered to fetch the user detail from the API.
            throw Error(`User ${user_id} not found in this clan ${this.id}!`);
        });
    }
    async loadChannels() {
        if (this._channelsLoaded)
            return;
        if (this._loadingPromise)
            return this._loadingPromise;
        this._loadingPromise = (async () => {
            var _a, _b;
            console.log("---------- call api listChannelDescs");
            const channels = await this.apiClient.listChannelDescs(this.sessionToken, constants_1.ChannelType.CHANNEL_TYPE_CHANNEL, this.id);
            const validChannels = (_b = (_a = channels === null || channels === void 0 ? void 0 : channels.channeldesc) === null || _a === void 0 ? void 0 : _a.filter((c) => Object.keys(c).length > 0)) !== null && _b !== void 0 ? _b : [];
            for (const channel of validChannels) {
                const channelObj = new TextChannel_1.TextChannel(Object.assign(Object.assign({}, channel), { type: (channel === null || channel === void 0 ? void 0 : channel.channel_type) || (channel === null || channel === void 0 ? void 0 : channel.type) }), this, this.socketManager, this.messageQueue);
                this.channels.set(channel.channel_id, channelObj);
                this.client.channels.set(channel.channel_id, channelObj);
            }
            this._channelsLoaded = true;
        })();
        return this._loadingPromise;
    }
    async listChannelVoiceUsers(channel_id = "", channel_type = constants_1.ChannelType.CHANNEL_TYPE_GMEET_VOICE, limit = 500, state, cursor) {
        const clanId = this.id;
        if (limit <= 0 || limit > 500) {
            console.log("0 < limit <= 500");
            throw new Error("0 < limit <= 500");
        }
        return this.apiClient
            .listChannelVoiceUsers(this.sessionToken, clanId, channel_id, channel_type, limit, state, cursor)
            .then((response) => {
            var result = {
                voice_channel_users: [],
            };
            if (response.voice_channel_users == null) {
                return Promise.resolve(result);
            }
            response.voice_channel_users.forEach((gu) => {
                result.voice_channel_users.push({
                    id: gu.id,
                    channel_id: gu.channel_id,
                    user_id: gu.user_id,
                    participant: gu.participant,
                });
            });
            return Promise.resolve(result);
        });
    }
}
exports.Clan = Clan;
//# sourceMappingURL=Clan.js.map