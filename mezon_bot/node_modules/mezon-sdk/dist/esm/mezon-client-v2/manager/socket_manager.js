import { Events } from "../../constants";
import { DefaultSocket } from "../../socket";
import { WebSocketAdapterPb } from "../../web_socket_adapter_pb";
import { Clan } from "../structures/Clan";
export class SocketManager {
    host;
    port;
    useSSL;
    adapter;
    sessionManager;
    apiClient;
    apiKey;
    eventManager;
    messageQueue;
    client;
    socket;
    isHardDisconnect;
    constructor(host, port, useSSL, adapter, sessionManager, apiClient, apiKey, eventManager, messageQueue, client) {
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.adapter = adapter;
        this.sessionManager = sessionManager;
        this.apiClient = apiClient;
        this.apiKey = apiKey;
        this.eventManager = eventManager;
        this.messageQueue = messageQueue;
        this.client = client;
        this.socket = new DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    createSocket() {
        this.adapter = new WebSocketAdapterPb();
        this.socket = new DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    getSocket() {
        return this.socket;
    }
    async connect(sockSession) {
        const session = await this.socket.connect(sockSession, true);
        this.isHardDisconnect = false;
        return session;
    }
    closeSocket() {
        this.isHardDisconnect = true;
        this.socket.close();
        console.log("eventManager", this.eventManager);
    }
    isOpen() {
        return this.socket.isOpen();
    }
    async onerror(evt) {
        console.log("onerror", evt);
        if (this.isHardDisconnect)
            return;
        if (this.socket.isOpen()) {
            await this.retriesConnect();
        }
    }
    onheartbeattimeout() {
        console.log("Heartbeat timeout.");
    }
    ondisconnect(e) {
        console.log("Disconnected!", e?.reason);
        if (this.isHardDisconnect)
            return;
        this.retriesConnect();
    }
    async connectSocket(sessionToken) {
        const clans = await this.apiClient.listClanDescs(sessionToken);
        clans.clandesc?.forEach(async (clan) => {
            await this.socket.joinClanChat(clan.clan_id || "");
            if (!this.client.clans.get(clan.clan_id)) {
                const clanObj = new Clan({
                    id: clan.clan_id,
                    name: clan?.clan_name ?? "unknown",
                }, this.client, this.apiClient, this, sessionToken, this.messageQueue);
                this.client.clans.set(clan.clan_id, clanObj);
            }
        });
        // join direct message
        await this.socket.joinClanChat("0");
        ["ondisconnect", "onerror", "onheartbeattimeout"].forEach((event) => {
            this.socket[event] = this[event].bind(this);
        });
        for (const event in Events) {
            const key = Events[event].toString();
            this.socket.socketEvents.on(key, (...args) => {
                this.client.emit(key, ...args);
            });
        }
    }
    async retriesConnect() {
        let retryInterval = 5000;
        const maxRetryInterval = 60000;
        console.log("Reconnecting...");
        const interval = setInterval(async () => {
            try {
                this.createSocket();
                const sockSession = await this.sessionManager.authenticate(this.apiKey);
                const sessionConnected = await this.connect(sockSession);
                if (sessionConnected?.token) {
                    await this.connectSocket(sessionConnected.token);
                }
                console.log("Connected successfully!");
                clearInterval(interval);
            }
            catch (e) {
                console.log("Connection failed:", e);
                retryInterval = Math.min(retryInterval * 2, maxRetryInterval);
                console.log(`Retrying in ${retryInterval / 1000} seconds...`);
                clearInterval(interval);
                setTimeout(() => this.retriesConnect(), retryInterval);
            }
        }, retryInterval);
    }
    async writeChatMessage(dataWriteMessage) {
        try {
            const msgACK = await this.socket.writeChatMessage(dataWriteMessage.clan_id, dataWriteMessage.channel_id, dataWriteMessage.mode, dataWriteMessage.is_public, dataWriteMessage.content, dataWriteMessage?.mentions ?? [], dataWriteMessage?.attachments ?? [], dataWriteMessage?.references ?? [], dataWriteMessage?.anonymous_message, dataWriteMessage?.mention_everyone, dataWriteMessage?.avatar, dataWriteMessage?.code, dataWriteMessage?.topic_id);
            return msgACK;
        }
        catch (error) {
            console.log("Error writeChatMessage", error);
            throw error;
        }
    }
    async updateChatMessage(dataUpdateMessage) {
        try {
            const msgACK = await this.socket.updateChatMessage(dataUpdateMessage.clan_id, dataUpdateMessage.channel_id, dataUpdateMessage.mode, dataUpdateMessage.is_public, dataUpdateMessage.message_id, dataUpdateMessage.content, dataUpdateMessage?.mentions ?? [], dataUpdateMessage?.attachments ?? [], dataUpdateMessage?.hideEditted ?? false, dataUpdateMessage?.topic_id);
            return msgACK;
        }
        catch (error) {
            console.log("Error updateChatMessage", error);
            throw error;
        }
    }
    async writeMessageReaction(dataReactionMessage) {
        try {
            const msgACK = await this.socket.writeMessageReaction(dataReactionMessage.id ?? "", dataReactionMessage.clan_id, dataReactionMessage.channel_id, dataReactionMessage.mode, dataReactionMessage.is_public, dataReactionMessage.message_id, dataReactionMessage.emoji_id, dataReactionMessage.emoji, dataReactionMessage.count, dataReactionMessage.message_sender_id, dataReactionMessage?.action_delete ?? false);
            return msgACK;
        }
        catch (error) {
            console.log("Error writeMessageReaction", error);
            throw error;
        }
    }
    async removeChatMessage(dataRemoveMessage) {
        try {
            const msgACK = await this.socket.removeChatMessage(dataRemoveMessage.clan_id, dataRemoveMessage.channel_id, dataRemoveMessage.mode, dataRemoveMessage.is_public, dataRemoveMessage.message_id);
            return msgACK;
        }
        catch (error) {
            console.log("Error removeChatMessage", error);
            throw error;
        }
    }
}
//# sourceMappingURL=socket_manager.js.map