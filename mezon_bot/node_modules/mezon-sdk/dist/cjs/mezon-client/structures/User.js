"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const constants_1 = require("../../constants");
class User {
    constructor(initUserData, clan, messageQueue, socketManager, channelManager) {
        var _a, _b, _c, _d, _e, _f;
        this.id = initUserData.id;
        this.avartar = (_a = initUserData.avartar) !== null && _a !== void 0 ? _a : "";
        this.dmChannelId = (_b = initUserData === null || initUserData === void 0 ? void 0 : initUserData.dmChannelId) !== null && _b !== void 0 ? _b : "";
        this.username = (_c = initUserData === null || initUserData === void 0 ? void 0 : initUserData.username) !== null && _c !== void 0 ? _c : "";
        this.clan_nick = (_d = initUserData === null || initUserData === void 0 ? void 0 : initUserData.clan_nick) !== null && _d !== void 0 ? _d : "";
        this.clan_avatar = (_e = initUserData === null || initUserData === void 0 ? void 0 : initUserData.clan_avatar) !== null && _e !== void 0 ? _e : "";
        this.display_name = (_f = initUserData === null || initUserData === void 0 ? void 0 : initUserData.display_name) !== null && _f !== void 0 ? _f : "";
        this.clan = clan;
        this.channelManager = channelManager;
        this.messageQueue = messageQueue;
        this.socketManager = socketManager;
    }
    async getEphemeralKeyPair() {
        if (!this.clan.mmnClient) {
            throw new Error("MmnClient not initialized");
        }
        return this.clan.mmnClient.generateEphemeralKeyPair();
    }
    async getAddress(user_id) {
        if (!this.clan.mmnClient) {
            throw new Error("MmnClient not initialized");
        }
        return this.clan.mmnClient.getAddressFromUserId(user_id);
    }
    async getZkProofs(data) {
        if (!this.clan.zkClient) {
            throw new Error("ZkClient not initialized");
        }
        const req = {
            userId: data.user_id,
            jwt: data.jwt,
            address: data.address,
            ephemeralPublicKey: data.ephemeral_public_key,
        };
        return this.clan.zkClient.getZkProofs(req);
    }
    async getCurrentNonce(user_id, tag) {
        if (!this.clan.mmnClient) {
            throw new Error("MmnClient not initialized");
        }
        return this.clan.mmnClient.getCurrentNonce(user_id, tag || "pending");
    }
    async sendToken(tokenEvent) {
        if (!this.clan.mmnClient) {
            throw new Error("MmnClient not initialized");
        }
        try {
            return this.clan.mmnClient.sendTransaction({
                sender: tokenEvent.sender_id,
                recipient: tokenEvent.receiver_id,
                amount: this.clan.mmnClient.scaleAmountToDecimals(tokenEvent.amount),
                nonce: tokenEvent.nonce,
                textData: tokenEvent.note,
                extraInfo: tokenEvent.extra_attribute,
                publicKey: tokenEvent.public_key,
                privateKey: tokenEvent.private_key,
                zkProof: tokenEvent.zk_proof,
                zkPub: tokenEvent.zk_pub,
            });
        }
        catch (error) {
            console.log("Error sendToken");
            return null;
        }
    }
    async sendDM(content, code) {
        return this.messageQueue.enqueue(async () => {
            var _a;
            if (!this.dmChannelId) {
                const dmChannel = await this.createDmChannel();
                this.dmChannelId = (_a = dmChannel === null || dmChannel === void 0 ? void 0 : dmChannel.channel_id) !== null && _a !== void 0 ? _a : "";
            }
            if (!this.dmChannelId)
                throw Error(`Can not get dmChannelId for this user ${this.id}!`);
            const dataSendDm = {
                clan_id: "0",
                channel_id: this.dmChannelId,
                mode: constants_1.ChannelStreamMode.STREAM_MODE_DM,
                is_public: false,
                content,
                code,
            };
            return await this.socketManager.writeChatMessage(dataSendDm);
        });
    }
    async createDmChannel() {
        var _a;
        try {
            const dmChannel = await ((_a = this.channelManager) === null || _a === void 0 ? void 0 : _a.createDMchannel(this.id));
            return dmChannel !== null && dmChannel !== void 0 ? dmChannel : {};
        }
        catch (error) {
            console.log("Error createDmChannel User");
            return null;
        }
    }
    async listTransactionDetail(transactionId) {
        const session = this.clan.sessionToken;
        return this.clan.apiClient.listTransactionDetail(session, transactionId);
    }
}
exports.User = User;
//# sourceMappingURL=User.js.map