"use strict";
/**
 * Copyright 2020 The Mezon Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultSocket = void 0;
const web_socket_adapter_1 = require("./web_socket_adapter");
const constants_1 = require("./constants");
const stream_1 = require("stream");
const format_message_input_1 = require("./utils/format_message_input");
const message_socket_events_1 = __importDefault(require("./message-socket-events"));
/** A socket connection to Mezon server implemented with the DOM's WebSocket API. */
class DefaultSocket {
    constructor(host, port, useSSL = false, verbose = false, adapter = new web_socket_adapter_1.WebSocketAdapterText(), sendTimeoutMs = DefaultSocket.DefaultSendTimeoutMs) {
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.verbose = verbose;
        this.adapter = adapter;
        this.sendTimeoutMs = sendTimeoutMs;
        this.socketEvents = new stream_1.EventEmitter();
        this.cIds = {};
        this.nextCid = 1;
        this._heartbeatTimeoutMs = DefaultSocket.DefaultHeartbeatTimeoutMs;
    }
    generatecid() {
        const cid = this.nextCid.toString();
        ++this.nextCid;
        return cid;
    }
    isOpen() {
        return this.adapter.isOpen();
    }
    close() {
        this.adapter.close();
    }
    connect(session, createStatus = false, connectTimeoutMs = DefaultSocket.DefaultConnectTimeoutMs) {
        this.session = session;
        if (this.adapter.isOpen()) {
            return Promise.resolve(session);
        }
        const scheme = (this.useSSL) ? "wss://" : "ws://";
        this.adapter.connect(scheme, this.host, this.port, createStatus, session.token);
        this.adapter.onClose = (evt) => {
            this.ondisconnect(evt);
        };
        this.adapter.onError = (evt) => {
            this.onerror(evt);
        };
        message_socket_events_1.default.forEach(cl => {
            const instance = new cl(this);
            instance.excute();
        });
        this.adapter.onMessage = (message) => {
            if (this.verbose) {
                console.log("Response: %o", JSON.stringify(message));
            }
            /** Inbound message from server. */
            if (!message.cid) {
                for (const event in constants_1.InternalEventsSocket) {
                    const fieldName = constants_1.InternalEventsSocket[event];
                    if (Object.prototype.toString.call(message) === '[object Object]' && message.hasOwnProperty(fieldName) && message[fieldName]) {
                        const input = format_message_input_1.formatFunction.hasOwnProperty(fieldName) ? format_message_input_1.formatFunction[fieldName](message) : message[fieldName];
                        this.socketEvents.emit(fieldName, input);
                    }
                }
            }
            else {
                const executor = this.cIds[message.cid];
                if (!executor) {
                    if (this.verbose) {
                        console.error("No promise executor for message: %o", message);
                    }
                    return;
                }
                delete this.cIds[message.cid];
                if (message.error) {
                    executor.reject(message.error);
                }
                else {
                    executor.resolve(message);
                }
            }
        };
        return new Promise((resolve, reject) => {
            this.adapter.onOpen = (evt) => {
                if (this.verbose) {
                    console.log(evt);
                }
                this.pingPong();
                resolve(session);
            };
            this.adapter.onError = (evt) => {
                reject(evt);
                this.adapter.close();
            };
            setTimeout(() => {
                // if promise has resolved by now, the reject() is a no-op
                reject("The socket timed out when trying to connect.");
            }, connectTimeoutMs);
        });
    }
    disconnect(fireDisconnectEvent = true) {
        if (this.adapter.isOpen()) {
            this.adapter.close();
        }
        if (fireDisconnectEvent) {
            this.ondisconnect({});
        }
    }
    setHeartbeatTimeoutMs(ms) {
        this._heartbeatTimeoutMs = ms;
    }
    getHeartbeatTimeoutMs() {
        return this._heartbeatTimeoutMs;
    }
    ondisconnect(evt) {
        if (this.verbose) {
            console.log(evt);
        }
    }
    onerror(evt) {
        if (this.verbose) {
            console.log(evt);
        }
    }
    onheartbeattimeout() {
        if (this.verbose) {
            console.log("Heartbeat timeout.");
        }
    }
    send(message, sendTimeout = DefaultSocket.DefaultSendTimeoutMs) {
        const untypedMessage = message;
        return new Promise((resolve, reject) => {
            var _a;
            if (!this.adapter.isOpen()) {
                reject("Socket connection has not been established yet.");
            }
            else {
                if (untypedMessage.channel_message_send) {
                    untypedMessage.channel_message_send.content = JSON.stringify(untypedMessage.channel_message_send.content);
                }
                else if (untypedMessage.channel_message_update) {
                    untypedMessage.channel_message_update.content = JSON.stringify(untypedMessage.channel_message_update.content);
                }
                else if (untypedMessage.ephemeral_message_send) {
                    untypedMessage.ephemeral_message_send.message.content =
                        JSON.stringify((_a = untypedMessage.ephemeral_message_send.message) === null || _a === void 0 ? void 0 : _a.content);
                }
                const cid = this.generatecid();
                this.cIds[cid] = { resolve, reject };
                setTimeout(() => {
                    reject("The socket timed out while waiting for a response.");
                }, sendTimeout);
                /** Add id for promise executor. */
                untypedMessage.cid = cid;
                this.adapter.send(untypedMessage);
            }
        });
    }
    async joinClanChat(clan_id) {
        const response = await this.send({
            clan_join: {
                clan_id: clan_id,
            }
        });
        return response.clan_join;
    }
    async joinChat(clan_id, channel_id, channel_type, is_public) {
        const response = await this.send({
            channel_join: {
                clan_id: clan_id,
                channel_id: channel_id,
                channel_type: channel_type,
                is_public: is_public
            }
        });
        return response.channel;
    }
    leaveChat(clan_id, channel_id, channel_type, is_public) {
        return this.send({ channel_leave: { clan_id: clan_id, channel_id: channel_id, channel_type: channel_type, is_public: is_public } });
    }
    async removeChatMessage(clan_id, channel_id, mode, is_public, message_id) {
        const response = await this.send({
            channel_message_remove: {
                clan_id: clan_id,
                channel_id: channel_id,
                mode: mode,
                message_id: message_id,
                is_public: is_public
            }
        });
        return response.channel_message_ack;
    }
    async updateChatMessage(clan_id, channel_id, mode, is_public, message_id, content, mentions, attachments, hideEditted) {
        const response = await this.send({ channel_message_update: { clan_id: clan_id, channel_id: channel_id, message_id: message_id, content: content, mentions: mentions, attachments: attachments, mode: mode, is_public: is_public, hide_editted: hideEditted } });
        return response.channel_message_ack;
    }
    updateStatus(status) {
        return this.send({ status_update: { status: status } });
    }
    async writeEphemeralMessage(receiver_id, clan_id, channel_id, mode, is_public, content, mentions, attachments, references, anonymous_message, mention_everyone, avatar, code, topic_id) {
        try {
            const response = await this.send({
                ephemeral_message_send: {
                    receiver_id: receiver_id,
                    message: {
                        clan_id: clan_id,
                        channel_id: channel_id,
                        mode: mode,
                        is_public: is_public,
                        content: content,
                        mentions: mentions !== null && mentions !== void 0 ? mentions : [],
                        attachments: attachments !== null && attachments !== void 0 ? attachments : [],
                        references: references !== null && references !== void 0 ? references : [],
                        anonymous_message: anonymous_message,
                        mention_everyone: mention_everyone,
                        avatar: avatar,
                        code: code,
                        topic_id: topic_id,
                    }
                }
            });
            return response.channel_message;
        }
        catch (error) {
            console.log('writeEphemeralMessage', error);
            throw error;
        }
    }
    async writeChatMessage(clan_id, channel_id, mode, is_public, content, mentions, attachments, references, anonymous_message, mention_everyone, avatar, code, topic_id) {
        const response = await this.send({ channel_message_send: { clan_id: clan_id, channel_id: channel_id, mode: mode, is_public: is_public, content: content, mentions: mentions, attachments: attachments, references: references, anonymous_message: anonymous_message, mention_everyone: mention_everyone, avatar: avatar, code, topic_id } });
        return response.channel_message_ack;
    }
    async writeMessageReaction(id, clan_id, channel_id, mode, is_public, message_id, emoji_id, emoji, count, message_sender_id, action_delete) {
        const response = await this.send({ message_reaction_event: { id: id, clan_id: clan_id, channel_id: channel_id, mode: mode, is_public: is_public, message_id: message_id, emoji_id: emoji_id, emoji: emoji, count: count, message_sender_id: message_sender_id, action: action_delete } });
        return response.message_reaction_event;
    }
    async writeMessageTyping(clan_id, channel_id, mode, is_public) {
        const response = await this.send({ message_typing_event: { clan_id: clan_id, channel_id: channel_id, mode: mode, is_public: is_public } });
        return response.message_typing_event;
    }
    async writeLastSeenMessage(clan_id, channel_id, mode, message_id, timestamp_seconds) {
        const response = await this.send({ last_seen_message_event: { clan_id: clan_id, channel_id: channel_id, mode: mode, message_id: message_id, timestamp_seconds: timestamp_seconds } });
        return response.last_seen_message_event;
    }
    async writeLastPinMessage(clan_id, channel_id, mode, is_public, message_id, timestamp_seconds, operation) {
        const response = await this.send({ last_pin_message_event: { clan_id: clan_id, channel_id: channel_id, mode: mode, is_public: is_public, message_id: message_id, timestamp_seconds: timestamp_seconds, operation: operation } });
        return response.last_pin_message_event;
    }
    async writeVoiceJoined(id, clanId, clanName, voiceChannelId, voiceChannelLabel, participant, lastScreenshot) {
        const response = await this.send({ voice_joined_event: { clan_id: clanId, clan_name: clanName, id: id, participant: participant, voice_channel_id: voiceChannelId, voice_channel_label: voiceChannelLabel, last_screenshot: lastScreenshot } });
        return response.voice_joined_event;
    }
    async writeVoiceLeaved(id, clanId, voiceChannelId, voiceUserId) {
        const response = await this.send({ voice_leaved_event: { id: id, clan_id: clanId, voice_channel_id: voiceChannelId, voice_user_id: voiceUserId } });
        return response.voice_leaved_event;
    }
    async writeCustomStatus(clan_id, status) {
        const response = await this.send({ custom_status_event: { clan_id: clan_id, status: status } });
        return response.custom_status_event;
    }
    async checkDuplicateClanName(clan_name) {
        const response = await this.send({ clan_name_existed_event: { clan_name: clan_name } });
        return response.clan_name_existed_event;
    }
    async listClanEmojiByClanId(clan_id) {
        const response = await this.send({ emojis_listed_event: { clan_id: clan_id } });
        return response.emojis_listed_event;
    }
    async ListChannelByUserId() {
        const response = await this.send({ channel_desc_list_event: {} });
        return response.channel_desc_list_event;
    }
    async hashtagDMList(user_id, limit) {
        const response = await this.send({ hashtag_dm_list_event: { user_id: user_id, limit: limit } });
        return response.hashtag_dm_list_event;
    }
    async listClanStickersByClanId(clan_id) {
        const response = await this.send({ sticker_listed_event: { clan_id: clan_id } });
        return response.sticker_listed_event;
    }
    async getNotificationChannelSetting(channel_id) {
        const response = await this.send({ notification_channel_setting_event: { channel_id: channel_id } });
        return response.notification_channel_setting_event;
    }
    async getNotificationCategorySetting(category_id) {
        const response = await this.send({ notification_category_setting_event: { category_id: category_id } });
        return response.notification_category_setting_event;
    }
    async getNotificationClanSetting(clan_id) {
        const response = await this.send({ notification_clan_setting_event: { clan_id: clan_id } });
        return response.notification_clan_setting_event;
    }
    async getNotificationReactMessage(channel_id) {
        const response = await this.send({ notifi_react_message_event: { channel_id: channel_id } });
        return response.notifi_react_message_event;
    }
    async pingPong() {
        if (!this.adapter.isOpen()) {
            return;
        }
        try {
            await this.send({ ping: {} }, this._heartbeatTimeoutMs);
        }
        catch (_a) {
            if (this.adapter.isOpen()) {
                if (this.verbose) {
                    console.error("Server unreachable from heartbeat.");
                }
                this.onheartbeattimeout();
                this.adapter.close();
            }
            return;
        }
        // reuse the timeout as the interval for now.
        // we can separate them out into separate values if needed later.
        setTimeout(() => this.pingPong(), this._heartbeatTimeoutMs);
    }
    async sendToken(receiver_id, amount) {
        const response = await this.send({ token_sent_event: { receiver_id: receiver_id, amount: amount } });
        return response.token_sent_event;
    }
}
exports.DefaultSocket = DefaultSocket;
DefaultSocket.DefaultHeartbeatTimeoutMs = 10000;
DefaultSocket.DefaultSendTimeoutMs = 10000;
DefaultSocket.DefaultConnectTimeoutMs = 30000;
;
//# sourceMappingURL=socket.js.map