"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextChannel = void 0;
const constants_1 = require("../../constants");
const helper_1 = require("../../utils/helper");
const CacheManager_1 = require("../utils/CacheManager");
class TextChannel {
    constructor(initChannelData, clan, socketManager, messageQueue) {
        var _a, _b, _c;
        this.id = initChannelData.channel_id;
        this.name = initChannelData.channel_label;
        this.channel_type = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.type;
        this.is_private = !!(initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.channel_private);
        this.category_id = (_a = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.category_id) !== null && _a !== void 0 ? _a : "";
        this.category_name = (_b = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.category_name) !== null && _b !== void 0 ? _b : "";
        this.parent_id = (_c = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.parent_id) !== null && _c !== void 0 ? _c : "";
        this.clan = clan;
        this.messages = new CacheManager_1.CacheManager(async (message_id) => {
            // TODO: If the channel's message cache is empty,
            // and channel.messages.fetch(message_id) is called,
            // this function will be triggered to fetch the message detail from the API.
            throw Error(`Message ${message_id} not found on channel ${this.id}!`);
        }, 200);
        this.socketManager = socketManager;
        this.messageQueue = messageQueue;
    }
    async send(content) {
        return this.messageQueue.enqueue(async () => {
            const dataSend = {
                clan_id: this.clan.id,
                channel_id: this.id,
                mode: (0, helper_1.convertChanneltypeToChannelMode)(this.channel_type),
                is_public: !this.is_private,
                content,
            };
            return await this.socketManager.writeChatMessage(dataSend);
        });
    }
    async sendDM(sendDmPayload) {
        return this.messageQueue.enqueue(async () => {
            var _a;
            const user = this.clan.users.get(sendDmPayload.user_id);
            if (!user)
                throw Error("user not found!");
            let dmChannelId = user === null || user === void 0 ? void 0 : user.dmChannelId;
            if (!user.dmChannelId) {
                console.log("--------------- call api createDMchannel");
                const dmChannel = await user._createDmChannel();
                user.dmChannelId = (_a = dmChannel === null || dmChannel === void 0 ? void 0 : dmChannel.channel_id) !== null && _a !== void 0 ? _a : "";
            }
            if (!dmChannelId)
                throw Error(`Can not get dmChannelId for this user ${user.id}!`);
            const dataSendDm = {
                clan_id: "0",
                channel_id: dmChannelId,
                mode: constants_1.ChannelStreamMode.STREAM_MODE_DM,
                is_public: false,
                content: sendDmPayload.content,
            };
            return await this.socketManager.writeChatMessage(dataSendDm);
        });
    }
}
exports.TextChannel = TextChannel;
//# sourceMappingURL=TextChannel.js.map