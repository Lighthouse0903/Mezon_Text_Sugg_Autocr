/**
 * Copyright 2020 The Mezon Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import { CloseEvent, ErrorEvent } from "ws";
import { ApiMessageAttachment, ApiMessageMention, ApiMessageReaction, ApiMessageRef, Channel, ChannelDescListEvent, ChannelJoin, ChannelLeave, ChannelMessageAck, ChannelMessageRemove, ChannelMessageSend, ChannelMessageUpdate, ClanJoin, ClanNameExistedEvent, CustomStatusEvent, DropdownBoxSelected, EmojiListedEvent, HashtagDmListEvent, LastPinMessageEvent, LastSeenMessageEvent, MessageTypingEvent, NotificationCategorySettingEvent, NotificationChannelSettingEvent, NotificationClanSettingEvent, NotifiReactMessageEvent, Ping, Rpc, Socket, StatusFollow, StatusUnfollow, StatusUpdate, StrickerListedEvent, TokenSentEvent, VoiceJoinedEvent, VoiceLeavedEvent } from "./interfaces";
import { Session } from "./session";
import { WebSocketAdapter } from "./web_socket_adapter";
import { EventEmitter } from "stream";
import { WebrtcSignalingFwd, IncomingCallPush, MessageButtonClicked, ChannelAppEvent, EphemeralMessageSend } from "./rtapi/realtime";
/** A socket connection to Mezon server implemented with the DOM's WebSocket API. */
export declare class DefaultSocket implements Socket {
    readonly host: string;
    readonly port: string;
    readonly useSSL: boolean;
    verbose: boolean;
    readonly adapter: WebSocketAdapter;
    readonly sendTimeoutMs: number;
    static readonly DefaultHeartbeatTimeoutMs = 10000;
    static readonly DefaultSendTimeoutMs = 10000;
    static readonly DefaultConnectTimeoutMs = 30000;
    private readonly cIds;
    private nextCid;
    private _heartbeatTimeoutMs;
    socketEvents: EventEmitter;
    session: Session | undefined;
    constructor(host: string, port: string, useSSL?: boolean, verbose?: boolean, adapter?: WebSocketAdapter, sendTimeoutMs?: number);
    generatecid(): string;
    isOpen(): boolean;
    close(): void;
    connect(session: Session, createStatus?: boolean, connectTimeoutMs?: number): Promise<Session>;
    disconnect(fireDisconnectEvent?: boolean): void;
    setHeartbeatTimeoutMs(ms: number): void;
    getHeartbeatTimeoutMs(): number;
    ondisconnect(evt: CloseEvent): void;
    onerror(evt: ErrorEvent): void;
    onheartbeattimeout(): void;
    send(message: ChannelJoin | ChannelLeave | ChannelMessageSend | ChannelMessageUpdate | CustomStatusEvent | ChannelMessageRemove | MessageTypingEvent | LastSeenMessageEvent | Rpc | StatusFollow | StatusUnfollow | StatusUpdate | Ping | WebrtcSignalingFwd | IncomingCallPush | MessageButtonClicked | DropdownBoxSelected | ChannelAppEvent | EphemeralMessageSend, sendTimeout?: number): Promise<any>;
    joinClanChat(clan_id: string): Promise<ClanJoin>;
    joinChat(clan_id: string, channel_id: string, channel_type: number, is_public: boolean): Promise<Channel>;
    leaveChat(clan_id: string, channel_id: string, channel_type: number, is_public: boolean): Promise<void>;
    removeChatMessage(clan_id: string, channel_id: string, mode: number, is_public: boolean, message_id: string): Promise<ChannelMessageAck>;
    updateChatMessage(clan_id: string, channel_id: string, mode: number, is_public: boolean, message_id: string, content: any, mentions?: Array<ApiMessageMention>, attachments?: Array<ApiMessageAttachment>, hideEditted?: boolean): Promise<ChannelMessageAck>;
    updateStatus(status?: string): Promise<void>;
    writeEphemeralMessage(receiver_id: string, clan_id: string, channel_id: string, mode: number, is_public: boolean, content: any, mentions?: Array<ApiMessageMention>, attachments?: Array<ApiMessageAttachment>, references?: Array<ApiMessageRef>, anonymous_message?: boolean, mention_everyone?: Boolean, avatar?: string, code?: number, topic_id?: string): Promise<ChannelMessageAck>;
    writeChatMessage(clan_id: string, channel_id: string, mode: number, is_public: boolean, content: any, mentions?: Array<ApiMessageMention>, attachments?: Array<ApiMessageAttachment>, references?: Array<ApiMessageRef>, anonymous_message?: boolean, mention_everyone?: boolean, avatar?: string, code?: number, topic_id?: string): Promise<ChannelMessageAck>;
    writeMessageReaction(id: string, clan_id: string, channel_id: string, mode: number, is_public: boolean, message_id: string, emoji_id: string, emoji: string, count: number, message_sender_id: string, action_delete: boolean): Promise<ApiMessageReaction>;
    writeMessageTyping(clan_id: string, channel_id: string, mode: number, is_public: boolean): Promise<MessageTypingEvent>;
    writeLastSeenMessage(clan_id: string, channel_id: string, mode: number, message_id: string, timestamp_seconds: number): Promise<LastSeenMessageEvent>;
    writeLastPinMessage(clan_id: string, channel_id: string, mode: number, is_public: boolean, message_id: string, timestamp_seconds: number, operation: number): Promise<LastPinMessageEvent>;
    writeVoiceJoined(id: string, clanId: string, clanName: string, voiceChannelId: string, voiceChannelLabel: string, participant: string, lastScreenshot: string): Promise<VoiceJoinedEvent>;
    writeVoiceLeaved(id: string, clanId: string, voiceChannelId: string, voiceUserId: string): Promise<VoiceLeavedEvent>;
    writeCustomStatus(clan_id: string, status: string): Promise<CustomStatusEvent>;
    checkDuplicateClanName(clan_name: string): Promise<ClanNameExistedEvent>;
    listClanEmojiByClanId(clan_id: string): Promise<EmojiListedEvent>;
    ListChannelByUserId(): Promise<ChannelDescListEvent>;
    hashtagDMList(user_id: Array<string>, limit: number): Promise<HashtagDmListEvent>;
    listClanStickersByClanId(clan_id: string): Promise<StrickerListedEvent>;
    getNotificationChannelSetting(channel_id: string): Promise<NotificationChannelSettingEvent>;
    getNotificationCategorySetting(category_id: string): Promise<NotificationCategorySettingEvent>;
    getNotificationClanSetting(clan_id: string): Promise<NotificationClanSettingEvent>;
    getNotificationReactMessage(channel_id: string): Promise<NotifiReactMessageEvent>;
    private pingPong;
    sendToken(receiver_id: string, amount: number): Promise<TokenSentEvent>;
}
