import { MmnClient, ZkClient } from "mmn-client-js";
import { ChannelType } from "../../constants";
import { CacheManager } from "../utils/CacheManager";
import { TextChannel } from "./TextChannel";
import { User } from "./User";
export class Clan {
    id;
    name;
    welcome_channel_id;
    channels;
    users;
    sessionToken;
    apiClient;
    mmnClient;
    zkClient;
    // cache status load channel
    _channelsLoaded = false;
    // cache status load channel call api
    _loadingPromise = null;
    client;
    socketManager;
    messageQueue;
    messageDB;
    constructor(initClanData, client, apiClient, socketManager, sessionToken, messageQueue, messageDB, mmnApiUrl, zkApiUrl) {
        this.id = initClanData.id;
        this.name = initClanData.name;
        this.welcome_channel_id = initClanData.welcome_channel_id;
        this.client = client;
        this.apiClient = apiClient;
        this.socketManager = socketManager;
        this.messageQueue = messageQueue;
        this.sessionToken = sessionToken;
        this.messageDB = messageDB;
        this.channels = new CacheManager(async (channelId) => {
            return this.client.channels.fetch(channelId);
        });
        this.users = new CacheManager(async (user_id) => {
            const dmChannel = await this.client.createDMchannel(user_id);
            if (!dmChannel || !dmChannel?.channel_id) {
                throw Error(`User ${user_id} not found in this clan ${this.id}!`);
            }
            const userRaw = {
                id: user_id,
                dmChannelId: dmChannel.channel_id,
            };
            const user = new User(userRaw, this, this.messageQueue, this.socketManager);
            this.users.set(user_id, user);
            return user;
        });
        if (mmnApiUrl) {
            this.mmnClient = new MmnClient({
                baseUrl: mmnApiUrl,
            });
        }
        if (zkApiUrl) {
            this.zkClient = new ZkClient({
                endpoint: zkApiUrl,
            });
        }
    }
    getClientId() {
        return this.client.clientId;
    }
    async loadChannels() {
        if (this._channelsLoaded)
            return;
        if (this._loadingPromise)
            return this._loadingPromise;
        this._loadingPromise = (async () => {
            const channels = await this.apiClient.listChannelDescs(this.sessionToken, ChannelType.CHANNEL_TYPE_CHANNEL, this.id);
            const validChannels = channels?.channeldesc?.filter((c) => Object.keys(c).length > 0) ??
                [];
            for (const channel of validChannels) {
                const channelObj = new TextChannel({ ...channel, type: channel?.channel_type || channel?.type }, this, this.socketManager, this.messageQueue, this.messageDB);
                this.channels.set(channel.channel_id, channelObj);
                this.client.channels.set(channel.channel_id, channelObj);
            }
            this._channelsLoaded = true;
        })();
        return this._loadingPromise;
    }
    async listChannelVoiceUsers(channel_id = "", channel_type = ChannelType.CHANNEL_TYPE_GMEET_VOICE, limit = 500, state, cursor) {
        const clanId = this.id;
        if (limit <= 0 || limit > 500) {
            console.log("0 < limit <= 500");
            throw new Error("0 < limit <= 500");
        }
        return this.apiClient
            .listChannelVoiceUsers(this.sessionToken, clanId, channel_id, channel_type, limit, state, cursor)
            .then((response) => {
            var result = {
                voice_channel_users: [],
            };
            if (response.voice_channel_users == null) {
                return Promise.resolve(result);
            }
            response.voice_channel_users.forEach((gu) => {
                result.voice_channel_users.push({
                    id: gu.id,
                    channel_id: gu.channel_id,
                    user_id: gu.user_id,
                    participant: gu.participant,
                });
            });
            return Promise.resolve(result);
        });
    }
    async updateRole(roleId, request) {
        const session = this.sessionToken;
        return this.apiClient.updateRole(session, roleId, request);
    }
    async listRoles(limit, state, cursor) {
        const session = this.sessionToken;
        return this.apiClient.listRoles(session, this.id, limit, state, cursor);
    }
}
//# sourceMappingURL=Clan.js.map