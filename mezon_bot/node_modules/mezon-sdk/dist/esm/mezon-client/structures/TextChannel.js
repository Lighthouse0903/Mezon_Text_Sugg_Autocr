import { TypeMessage } from "../../constants";
import { convertChanneltypeToChannelMode, generateSnowflakeId, } from "../../utils/helper";
import { CacheManager } from "../utils/CacheManager";
import { Message } from "./Message";
export class TextChannel {
    id;
    name;
    is_private;
    channel_type;
    category_id;
    category_name;
    parent_id;
    meeting_code;
    clan;
    messages;
    socketManager;
    messageQueue;
    messageDB;
    constructor(initChannelData, clan, socketManager, messageQueue, messageDB) {
        this.id = initChannelData.channel_id;
        this.name = initChannelData.channel_label;
        this.channel_type = initChannelData?.type;
        this.is_private = !!initChannelData?.channel_private;
        this.category_id = initChannelData?.category_id ?? "";
        this.category_name = initChannelData?.category_name ?? "";
        this.parent_id = initChannelData?.parent_id ?? "";
        this.meeting_code = initChannelData?.meeting_code ?? "";
        this.clan = clan;
        this.messages = new CacheManager(async (message_id) => {
            const messageDb = this.messageDB.getMessageById(message_id, this.id);
            if (!messageDb) {
                throw Error(`Message ${message_id} not found on channel ${this.id}!`);
            }
            const newMessage = new Message(messageDb, this, this.socketManager, this.messageQueue);
            return newMessage;
        }, 200);
        this.socketManager = socketManager;
        this.messageQueue = messageQueue;
        this.messageDB = messageDB;
    }
    async send(content, mentions, attachments, mention_everyone, anonymous_message, topic_id, code) {
        return this.messageQueue.enqueue(async () => {
            const dataSend = {
                clan_id: this.clan.id,
                channel_id: this.id,
                mode: convertChanneltypeToChannelMode(this.channel_type),
                is_public: !this.is_private,
                content,
                mentions,
                attachments,
                anonymous_message,
                mention_everyone,
                code,
                topic_id,
            };
            return await this.socketManager.writeChatMessage(dataSend);
        });
    }
    async sendEphemeral(receiver_id, content, reference_message_id, mentions, attachments, mention_everyone, anonymous_message, topic_id, code = TypeMessage.Ephemeral) {
        return this.messageQueue.enqueue(async () => {
            let references = [];
            if (reference_message_id) {
                let messageRef = await this.messages.fetch(reference_message_id);
                const user = await this.clan.users.fetch(messageRef.sender_id);
                references = [
                    {
                        message_ref_id: messageRef.id,
                        message_sender_id: messageRef.sender_id,
                        message_sender_username: user.clan_nick || user.display_name || user.username,
                        mesages_sender_avatar: user.clan_avatar || user.avartar,
                        content: JSON.stringify(messageRef.content),
                    },
                ];
            }
            const dataSend = {
                receiver_id,
                clan_id: this.clan.id,
                channel_id: this.id,
                mode: convertChanneltypeToChannelMode(this.channel_type),
                is_public: !this.is_private,
                content,
                mentions,
                attachments,
                references: references ?? [],
                anonymous_message,
                mention_everyone,
                code,
                topic_id,
            };
            return await this.socketManager.writeEphemeralMessage(dataSend);
        });
    }
    async addQuickMenuAccess(body) {
        const id = generateSnowflakeId();
        const bot_id = this.clan.getClientId();
        const payload = {
            channel_id: "0",
            clan_id: body?.clan_id ?? "0",
            menu_type: body?.menu_type ?? 1,
            action_msg: body.action_msg,
            background: body?.background ?? "",
            menu_name: body.menu_name,
            id,
            bot_id,
        };
        try {
            return await this.clan.apiClient.addQuickMenuAccess(this.clan.sessionToken, payload);
        }
        catch (error) {
            throw error;
        }
    }
    async deleteQuickMenuAccess(botId) {
        const botIdPayload = botId ?? this.clan.getClientId();
        try {
            return await this.clan.apiClient.deleteQuickMenuAccess(this.clan.sessionToken, botIdPayload);
        }
        catch (error) {
            throw error;
        }
    }
    async playMedia(url, participantIdentity, participantName, name) {
        const meetingCode = this.meeting_code;
        if (!meetingCode) {
            return { error: "Channel not voice channel." };
        }
        const token = this.clan.sessionToken;
        if (!token) {
            return { error: "Token not found." };
        }
        const payload = {
            room_name: meetingCode,
            participant_identity: participantIdentity,
            participant_name: participantName,
            url: url,
            name: name,
        };
        try {
            return await this.clan.apiClient.playMedia(token, payload);
        }
        catch (error) {
            throw error;
        }
    }
}
//# sourceMappingURL=TextChannel.js.map