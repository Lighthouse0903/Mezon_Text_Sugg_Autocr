import { DefaultSocket } from "../socket";
import { Events } from "../constants";
import { WebSocketAdapterPb } from "../web_socket_adapter_pb";
export class SocketManager {
    host;
    port;
    useSSL;
    adapter;
    sessionManager;
    apiClient;
    apiKey;
    eventManager;
    socket;
    isHardDisconnect;
    constructor(host, port, useSSL, adapter, sessionManager, apiClient, apiKey, eventManager) {
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.adapter = adapter;
        this.sessionManager = sessionManager;
        this.apiClient = apiClient;
        this.apiKey = apiKey;
        this.eventManager = eventManager;
        this.socket = new DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    createSocket() {
        this.adapter = new WebSocketAdapterPb();
        this.socket = new DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    getSocket() {
        return this.socket;
    }
    async connect(sockSession) {
        const session = await this.socket.connect(sockSession, true);
        this.isHardDisconnect = false;
        return session;
    }
    closeSocket() {
        this.isHardDisconnect = true;
        this.socket.close();
    }
    isOpen() {
        return this.socket.isOpen();
    }
    async onerror(evt) {
        console.log("onerror", evt);
        if (this.isHardDisconnect)
            return;
        if (this.socket.isOpen()) {
            await this.retriesConnect();
        }
    }
    onheartbeattimeout() {
        console.log("Heartbeat timeout.");
    }
    ondisconnect(e) {
        console.log("Disconnected!", e?.reason);
        if (this.isHardDisconnect)
            return;
        this.retriesConnect();
    }
    async connectSocket(sessionToken) {
        const clans = await this.apiClient.listClanDescs(sessionToken);
        clans.clandesc?.forEach(async (clan) => {
            await this.socket.joinClanChat(clan.clan_id || "");
        });
        // join direct message
        await this.socket.joinClanChat("0");
        ["ondisconnect", "onerror", "onheartbeattimeout"].forEach((event) => {
            this.socket[event] = this[event].bind(this);
        });
        for (const event in Events) {
            const key = Events[event].toString();
            this.socket.socketEvents.on(key, (...args) => {
                this.eventManager.emit(key, ...args);
            });
        }
    }
    async retriesConnect() {
        let retryInterval = 5000;
        const maxRetryInterval = 60000;
        console.log("Reconnecting...");
        const interval = setInterval(async () => {
            try {
                this.createSocket();
                const sockSession = await this.sessionManager.authenticate(this.apiKey);
                const sessionConnected = await this.connect(sockSession);
                if (sessionConnected?.token) {
                    await this.connectSocket(sessionConnected.token);
                }
                console.log("Connected successfully!");
                clearInterval(interval);
            }
            catch (e) {
                console.log("Connection failed:", e);
                retryInterval = Math.min(retryInterval * 2, maxRetryInterval);
                console.log(`Retrying in ${retryInterval / 1000} seconds...`);
                clearInterval(interval);
                setTimeout(() => this.retriesConnect(), retryInterval);
            }
        }, retryInterval);
    }
}
//# sourceMappingURL=socket_manager.js.map