"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Collection extends Map {
    constructor(entries) {
        super(entries !== null && entries !== void 0 ? entries : []);
    }
    get size() {
        return super.size;
    }
    set(key, value) {
        super.set(key, value);
        return this;
    }
    delete(key) {
        return super.delete(key);
    }
    has(key) {
        return super.has(key);
    }
    get(key) {
        return super.get(key);
    }
    first() {
        return this.values().next().value;
    }
    firstKey() {
        return this.keys().next().value;
    }
    last() {
        return [...this.values()].at(-1);
    }
    filter(fn) {
        const filtered = new Collection();
        for (const [key, value] of this) {
            if (fn(value, key, this)) {
                filtered.set(key, value);
            }
        }
        return filtered;
    }
    find(fn) {
        for (const [key, value] of this) {
            if (fn(value, key, this))
                return value;
        }
        return undefined;
    }
    map(fn) {
        const result = [];
        for (const [key, value] of this) {
            result.push(fn(value, key, this));
        }
        return result;
    }
    some(fn) {
        for (const [key, value] of this) {
            if (fn(value, key, this))
                return true;
        }
        return false;
    }
    every(fn) {
        for (const [key, value] of this) {
            if (!fn(value, key, this))
                return false;
        }
        return true;
    }
    reduce(fn, initialValue) {
        let acc = initialValue;
        for (const [key, value] of this) {
            acc = fn(acc, value, key, this);
        }
        return acc;
    }
    random() {
        const arr = [...this.values()];
        if (!arr.length)
            return undefined;
        return arr[Math.floor(Math.random() * arr.length)];
    }
    sort(compareFn) {
        const sorted = [...this.entries()].sort((a, b) => compareFn ? compareFn(a[1], b[1]) : 0);
        return new Collection(sorted);
    }
    clear() {
        super.clear();
    }
    keysArray() {
        return [...this.keys()];
    }
    valuesArray() {
        return [...this.values()];
    }
    entriesArray() {
        return [...this.entries()];
    }
}
exports.default = Collection;
//# sourceMappingURL=Collection.js.map