// src/client/MezonClient.ts
import { EventEmitter } from "events";
import { CacheManager } from "../utils/CacheManager";
import { TextChannel } from "../structures/TextChannel";
// import { User } from "../structures/User";
import { Message } from "../structures/Message";
import { MezonApi } from "../../api";
import { SocketManager } from "../manager/socket_manager";
import { SessionManager } from "../manager/session_manager";
import { EventManager } from "../manager/event_manager";
import { WebSocketAdapterPb } from "../../web_socket_adapter_pb";
import { ChannelType, Events } from "../../constants";
import { isValidUserId, sleep } from "../../utils/helper";
import { ChannelManager } from "../manager/channel_manager";
import { User } from "../structures/User";
import { AsyncThrottleQueue } from "../utils/AsyncThrottleQueue";
const DEFAULT_HOST = "api.mezon.vn";
const DEFAULT_PORT = "443";
const DEFAULT_API_KEY = "";
const DEFAULT_SSL = true;
const DEFAULT_TIMEOUT_MS = 7000;
export class MezonClient extends EventEmitter {
    host;
    port;
    useSSL;
    timeout;
    token;
    apiClient;
    socketManager;
    channelManager;
    sessionManager;
    clientId;
    eventManager;
    messageQueue = new AsyncThrottleQueue();
    clans;
    channels;
    constructor(token = DEFAULT_API_KEY, host = DEFAULT_HOST, port = DEFAULT_PORT, useSSL = DEFAULT_SSL, timeout = DEFAULT_TIMEOUT_MS) {
        super();
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.timeout = timeout;
        const scheme = useSSL ? "https://" : "http://";
        const basePath = `${scheme}${host}:${port}`;
        this.token = token;
        this.apiClient = new MezonApi(token, basePath, timeout);
        // this.users = new CacheManager(this._fetchUserFromAPI.bind(this)); // TODO: add user
        this.clans = new CacheManager(this._fetchClanFromAPI.bind(this));
        this.channels = new CacheManager(this._fetchChannelFromAPI.bind(this));
        this.sessionManager = new SessionManager(this.apiClient);
        this.eventManager = new EventManager();
        this.socketManager = new SocketManager(this.host, this.port, this.useSSL, new WebSocketAdapterPb(), this.sessionManager, this.apiClient, this.token, this.eventManager, this.messageQueue, this);
        this.channelManager = new ChannelManager(this.apiClient, this.socketManager, this.sessionManager);
    }
    /** Login bot */
    async login() {
        const sockSession = await this.sessionManager.authenticate(this.token);
        this.clientId = sockSession?.user_id;
        const sessionConnected = await this.socketManager.connect(sockSession);
        if (sessionConnected?.token) {
            await this.socketManager.connectSocket(sessionConnected.token);
            await this.channelManager.initAllDmChannels(sessionConnected.token);
        }
        this.emit("ready");
        return "Authenticate success!";
    }
    /** Create DM channel */
    async createDMchannel(userId) {
        try {
            if (!isValidUserId(userId))
                return null;
            const socket = this.socketManager.getSocket();
            const request = {
                clan_id: "",
                channel_id: "0",
                category_id: "0",
                type: ChannelType.CHANNEL_TYPE_DM,
                user_ids: [userId],
                channel_private: 1,
            };
            const channelDM = await this.apiClient.createChannelDesc(this.sessionManager.getSession().token, request);
            if (channelDM) {
                await sleep(100);
                await socket.joinChat(channelDM.clan_id, channelDM.channel_id, channelDM.type, false);
                return channelDM;
            }
            return null;
        }
        catch (e) {
            console.log(e);
            return null;
        }
    }
    async sendToken(sendTokenData) {
        const session = this.sessionManager.getSession();
        return this.apiClient.sendToken(session.token, sendTokenData);
    }
    /** Listen to messages user sends on the  channel, thread */
    async onChannelMessage(listener) {
        this.on(Events.ChannelMessage.toString(), async (e) => {
            // handle init cache channel, message, user
            await this._initChannelMessageCache(e);
            await this._initUserClanCache(e);
            listener(e);
        });
        return this;
    }
    /** Listen to channel created */
    onChannelCreated(listener) {
        this.on(Events.ChannelCreated.toString(), async (e) => {
            this._updateCacheChannel(e);
            listener(e);
        });
        return this;
    }
    /** Listen to channel updated */
    onChannelUpdated(listener) {
        this.on(Events.ChannelUpdated.toString(), async (e) => {
            if (e.channel_type === ChannelType.CHANNEL_TYPE_THREAD &&
                e.status === 1) {
                const socket = this.socketManager.getSocket();
                await socket.joinChat(e.clan_id, e.channel_id, e.channel_type, false);
            }
            this._updateCacheChannel(e);
            listener(e);
        });
        return this;
    }
    /** Listen to channel deleted */
    onChannelDeleted(listener) {
        this.on(Events.ChannelDeleted.toString(), async (e) => {
            const clan = this.clans.get(e.clan_id);
            if (!clan)
                return;
            this.channels.delete(e.channel_id);
            clan.channels.delete(e.channel_id);
            listener(e);
        });
        return this;
    }
    /** Listen to user send token to each other */
    onTokenSend(listener) {
        this.on(Events.TokenSend.toString(), listener);
        return this;
    }
    /** Listen to user react to messages on the channel, thread */
    onMessageReaction(listener) {
        this.on(Events.MessageReaction.toString(), listener);
        return this;
    }
    /** Listen to user react to messages on the channel, thread */
    onUserChannelRemoved(listener) {
        this.on(Events.UserChannelRemoved.toString(), listener);
        return this;
    }
    /** Listen to user leaved/removed in the channel */
    onUserClanRemoved(listener) {
        this.on(Events.UserClanRemoved.toString(), async (e) => {
            const clan = this.clans.get(e.clan_id);
            if (!clan)
                return;
            e.user_ids.forEach((user_id) => {
                clan.users.delete(user_id);
            });
            listener(e);
        });
        return this;
    }
    /** Listen to user added in the channel */
    onUserChannelAdded(listener) {
        this.on(Events.UserChannelAdded.toString(), async (e) => {
            const socket = this.socketManager.getSocket();
            if (e?.users?.some((user) => user.user_id == this.clientId)) {
                await socket.joinChat(e.clan_id, e.channel_desc.channel_id, e.channel_desc.type, !e.channel_desc.channel_private);
            }
            listener(e);
        });
        return this;
    }
    /** Listen to users give coffee to each other */
    onGiveCoffee(listener) {
        this.on(Events.GiveCoffee.toString(), listener);
        return this;
    }
    /** Listen to clan create new role */
    onRoleEvent(listener) {
        this.on(Events.RoleEvent.toString(), listener);
        return this;
    }
    /** Listen to assigning a role to user */
    onRoleAssign(listener) {
        this.on(Events.RoleAssign.toString(), listener);
        return this;
    }
    /** Listen to user added in CLAN */
    onAddClanUser(listener) {
        this.on(Events.AddClanUser.toString(), listener);
        return this;
    }
    /** Listen to clan create a new event */
    onClanEventCreated(listener) {
        this.on(Events.ClanEventCreated.toString(), listener);
        return this;
    }
    /** Listen to user lick a button on embed message */
    onMessageButtonClicked(listener) {
        this.on(Events.MessageButtonClicked.toString(), listener);
        return this;
    }
    /** Listen to user joined a stream room */
    onStreamingJoinedEvent(listener) {
        this.on(Events.StreamingJoinedEvent.toString(), listener);
        return this;
    }
    /** Listen to user leaved a stream room */
    onStreamingLeavedEvent(listener) {
        this.on(Events.StreamingLeavedEvent.toString(), listener);
        return this;
    }
    /** Listen to user selected a input dropdown */
    onDropdownBoxSelected(listener) {
        this.on(Events.DropdownBoxSelected.toString(), listener);
        return this;
    }
    /** Listen to user accepted call 1-1 */
    onWebrtcSignalingFwd(listener) {
        this.on(Events.WebrtcSignalingFwd.toString(), listener);
        return this;
    }
    closeSocket() {
        this.socketManager.closeSocket();
        this.eventManager = new EventManager(); // Reset event manager
    }
    async _fetchClanFromAPI(id) {
        throw Error(`Can not find clan ${id}!`);
    }
    async _fetchChannelFromAPI(id) {
        console.log("_fetchChannelFromAPI", id);
        const session = this.sessionManager.getSession();
        const channelDetail = await this.apiClient.listChannelDetail(session.token, id);
        if (!channelDetail?.clan_id || channelDetail?.clan_id === "0") {
            throw Error(`Cannot fetch channelDM ${channelDetail?.channel_id ?? ""}!`);
        }
        const clanId = channelDetail.clan_id;
        const clan = this.clans.get(clanId);
        const channel = new TextChannel(channelDetail, clan, this.socketManager, this.messageQueue);
        this.channels.set(channel.id, channel);
        clan.channels.set(channel.id, channel);
        return channel;
    }
    async _initChannelMessageCache(e) {
        const { clan_id, channel_id, sender_id, message_id, content, reactions, mentions, attachments, references, } = e;
        if (!clan_id || clan_id === "0")
            return;
        const clan = this.clans.get(clan_id);
        if (!clan)
            return;
        await clan.loadChannels();
        const channel = await this.channels.fetch(channel_id);
        const messageRaw = {
            id: message_id,
            clan_id: clan_id,
            channel_id: channel_id,
            sender_id: sender_id,
            content,
            reactions,
            mentions,
            attachments,
            references,
        };
        const message = new Message(messageRaw, channel, this.socketManager, this.messageQueue);
        channel.messages.set(message_id, message);
    }
    async _initUserClanCache(e) {
        const { clan_id, sender_id, username, clan_nick, clan_avatar, avatar, display_name, } = e;
        const clan = this.clans.get(clan_id);
        if (clan) {
            let userCache = clan.users.get(sender_id);
            let dmChannelId = userCache?.dmChannelId ?? "";
            if (!userCache && sender_id !== this.clientId) {
                const allDmChannel = this.channelManager.getAllDmChannels();
                dmChannelId = allDmChannel?.[sender_id] ?? "";
            }
            const userRaw = {
                id: sender_id,
                username: username,
                clan_nick: clan_nick,
                clan_avatar: clan_avatar,
                avartar: avatar,
                display_name: display_name,
                dmChannelId,
            };
            const user = new User(userRaw, clan, this.channelManager);
            clan.users.set(sender_id, user);
        }
    }
    _updateCacheChannel(e) {
        const clan = this.clans.get(e.clan_id);
        if (!clan)
            return;
        const channelObj = new TextChannel({
            ...e,
            type: e.channel_type,
            channel_private: e.channel_private ? 1 : 0,
        }, clan, this.socketManager, this.messageQueue);
        this.channels.set(e.channel_id, channelObj);
        clan.channels.set(e.channel_id, channelObj);
        this.socketManager.getSocket().joinChat;
    }
}
//# sourceMappingURL=MezonClient.js.map