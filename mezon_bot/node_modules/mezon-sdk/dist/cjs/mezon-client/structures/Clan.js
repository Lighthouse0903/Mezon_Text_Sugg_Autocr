"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Clan = void 0;
const constants_1 = require("../../constants");
const CacheManager_1 = require("../utils/CacheManager");
const TextChannel_1 = require("./TextChannel");
const User_1 = require("./User");
class Clan {
    constructor(initClanData, client, apiClient, socketManager, sessionToken, messageQueue, messageDB) {
        // cache status load channel
        this._channelsLoaded = false;
        // cache status load channel call api
        this._loadingPromise = null;
        this.id = initClanData.id;
        this.name = initClanData.name;
        this.welcome_channel_id = initClanData.welcome_channel_id;
        this.client = client;
        this.apiClient = apiClient;
        this.socketManager = socketManager;
        this.messageQueue = messageQueue;
        this.sessionToken = sessionToken;
        this.messageDB = messageDB;
        this.channels = new CacheManager_1.CacheManager(async (channelId) => {
            return this.client.channels.fetch(channelId);
        });
        this.users = new CacheManager_1.CacheManager(async (user_id) => {
            const dmChannel = await this.client.createDMchannel(user_id);
            if (!dmChannel || !(dmChannel === null || dmChannel === void 0 ? void 0 : dmChannel.channel_id)) {
                throw Error(`User ${user_id} not found in this clan ${this.id}!`);
            }
            const userRaw = {
                id: user_id,
                dmChannelId: dmChannel.channel_id,
            };
            const user = new User_1.User(userRaw, this, this.messageQueue, this.socketManager);
            this.users.set(user_id, user);
            return user;
        });
    }
    getClientId() {
        return this.client.clientId;
    }
    async loadChannels() {
        if (this._channelsLoaded)
            return;
        if (this._loadingPromise)
            return this._loadingPromise;
        this._loadingPromise = (async () => {
            var _a, _b;
            const channels = await this.apiClient.listChannelDescs(this.sessionToken, constants_1.ChannelType.CHANNEL_TYPE_CHANNEL, this.id);
            const validChannels = (_b = (_a = channels === null || channels === void 0 ? void 0 : channels.channeldesc) === null || _a === void 0 ? void 0 : _a.filter((c) => Object.keys(c).length > 0)) !== null && _b !== void 0 ? _b : [];
            for (const channel of validChannels) {
                const channelObj = new TextChannel_1.TextChannel(Object.assign(Object.assign({}, channel), { type: (channel === null || channel === void 0 ? void 0 : channel.channel_type) || (channel === null || channel === void 0 ? void 0 : channel.type) }), this, this.socketManager, this.messageQueue, this.messageDB);
                this.channels.set(channel.channel_id, channelObj);
                this.client.channels.set(channel.channel_id, channelObj);
            }
            this._channelsLoaded = true;
        })();
        return this._loadingPromise;
    }
    async listChannelVoiceUsers(channel_id = "", channel_type = constants_1.ChannelType.CHANNEL_TYPE_GMEET_VOICE, limit = 500, state, cursor) {
        const clanId = this.id;
        if (limit <= 0 || limit > 500) {
            console.log("0 < limit <= 500");
            throw new Error("0 < limit <= 500");
        }
        return this.apiClient
            .listChannelVoiceUsers(this.sessionToken, clanId, channel_id, channel_type, limit, state, cursor)
            .then((response) => {
            var result = {
                voice_channel_users: [],
            };
            if (response.voice_channel_users == null) {
                return Promise.resolve(result);
            }
            response.voice_channel_users.forEach((gu) => {
                result.voice_channel_users.push({
                    id: gu.id,
                    channel_id: gu.channel_id,
                    user_id: gu.user_id,
                    participant: gu.participant,
                });
            });
            return Promise.resolve(result);
        });
    }
    async updateRole(roleId, request) {
        const session = this.sessionToken;
        return this.apiClient.updateRole(session, roleId, request);
    }
    async listRoles(limit, state, cursor) {
        const session = this.sessionToken;
        return this.apiClient.listRoles(session, this.id, limit, state, cursor);
    }
}
exports.Clan = Clan;
//# sourceMappingURL=Clan.js.map