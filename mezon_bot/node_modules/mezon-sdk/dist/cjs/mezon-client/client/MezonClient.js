"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MezonClient = void 0;
// src/client/MezonClient.ts
const events_1 = require("events");
const CacheManager_1 = require("../utils/CacheManager");
const Clan_1 = require("../structures/Clan");
const TextChannel_1 = require("../structures/TextChannel");
// import { User } from "../structures/User";
const Message_1 = require("../structures/Message");
const api_1 = require("../../api");
const socket_manager_1 = require("../manager/socket_manager");
const session_manager_1 = require("../manager/session_manager");
const event_manager_1 = require("../manager/event_manager");
const web_socket_adapter_pb_1 = require("../../web_socket_adapter_pb");
const constants_1 = require("../../constants");
const helper_1 = require("../../utils/helper");
const channel_manager_1 = require("../manager/channel_manager");
const User_1 = require("../structures/User");
const AsyncThrottleQueue_1 = require("../utils/AsyncThrottleQueue");
const MessageDatabase_1 = require("../../sqlite/MessageDatabase");
const DEFAULT_HOST = "gw.mezon.ai";
const DEFAULT_PORT = "443";
const DEFAULT_API_KEY = "";
const DEFAULT_SSL = true;
const DEFAULT_TIMEOUT_MS = 7000;
class MezonClient extends events_1.EventEmitter {
    constructor(token = DEFAULT_API_KEY, host = DEFAULT_HOST, port = DEFAULT_PORT, useSSL = DEFAULT_SSL, timeout = DEFAULT_TIMEOUT_MS) {
        super();
        this.timeout = timeout;
        this.messageQueue = new AsyncThrottleQueue_1.AsyncThrottleQueue();
        const scheme = useSSL ? "https://" : "http://";
        this.token = token;
        this.host = host;
        this.useSSL = useSSL;
        this.port = port;
        this.loginBasePath = `${scheme}${host}:${port}`;
        this.messageDB = new MessageDatabase_1.MessageDatabase();
    }
    initManager(basePath, sessionApi) {
        this.eventManager = new event_manager_1.EventManager();
        this.clans = new CacheManager_1.CacheManager(this._fetchClanFromAPI.bind(this));
        this.channels = new CacheManager_1.CacheManager(this._fetchChannelFromAPI.bind(this));
        this.apiClient = new api_1.MezonApi(this.token, basePath, this.timeout);
        this.sessionManager = new session_manager_1.SessionManager(this.apiClient, sessionApi);
        this.socketManager = new socket_manager_1.SocketManager(this.host, this.port, this.useSSL, new web_socket_adapter_pb_1.WebSocketAdapterPb(), this.apiClient, this.eventManager, this.messageQueue, this, this.messageDB);
        this.channelManager = new channel_manager_1.ChannelManager(this.apiClient, this.socketManager, this.sessionManager);
    }
    /** Login bot */
    async login() {
        const tempApiClient = new api_1.MezonApi(this.token, this.loginBasePath, this.timeout);
        const tempSessionManager = new session_manager_1.SessionManager(tempApiClient);
        const sessionApi = await tempSessionManager.authenticate(this.token);
        if (sessionApi === null || sessionApi === void 0 ? void 0 : sessionApi.api_url) {
            const { host, port, useSSL } = (0, helper_1.parseUrlToHostAndSSL)(sessionApi.api_url);
            this.host = host;
            this.port = port || (useSSL ? "443" : "80");
            this.useSSL = useSSL;
            const scheme = this.useSSL ? "https://" : "http://";
            const basePath = `${scheme}${this.host}:${this.port}`;
            this.initManager(basePath, sessionApi);
        }
        this.clientId = sessionApi === null || sessionApi === void 0 ? void 0 : sessionApi.user_id;
        const sessionConnected = await this.socketManager.connect(sessionApi);
        if (sessionConnected === null || sessionConnected === void 0 ? void 0 : sessionConnected.token) {
            await this.socketManager.connectSocket(sessionConnected.token);
            await this.channelManager.initAllDmChannels(sessionConnected.token);
        }
        this.emit("ready");
        return JSON.stringify(sessionApi !== null && sessionApi !== void 0 ? sessionApi : {});
    }
    /** Create DM channel */
    async createDMchannel(userId) {
        try {
            if (!(0, helper_1.isValidUserId)(userId))
                return null;
            const socket = this.socketManager.getSocket();
            const request = {
                clan_id: "",
                channel_id: "0",
                category_id: "0",
                type: constants_1.ChannelType.CHANNEL_TYPE_DM,
                user_ids: [userId],
                channel_private: 1,
            };
            try {
                const channelDM = await this.apiClient.createChannelDesc(this.sessionManager.getSession().token, request);
                if (channelDM) {
                    await (0, helper_1.sleep)(100);
                    await socket.joinChat(channelDM.clan_id, channelDM.channel_id, channelDM.type, false);
                    const clanDm = this.clans.get("0");
                    if (clanDm) {
                        const userRaw = {
                            id: userId,
                            dmChannelId: channelDM.channel_id,
                        };
                        const user = new User_1.User(userRaw, clanDm, this.messageQueue, this.socketManager, this.channelManager);
                        clanDm.users.set(userId, user);
                    }
                    return channelDM;
                }
            }
            catch (error) {
                console.log("error createDMchannel", userId, error === null || error === void 0 ? void 0 : error.status);
            }
            return null;
        }
        catch (e) {
            return null;
        }
    }
    async sendToken(sendTokenData) {
        const session = this.sessionManager.getSession();
        return this.apiClient.sendToken(session.token, sendTokenData);
    }
    /** Listen to messages user sends on the  channel, thread */
    async onChannelMessage(listener) {
        this.on(constants_1.Events.ChannelMessage.toString(), async (e) => {
            // handle init cache channel, message, user
            await this._initChannelMessageCache(e);
            await this._initUserClanCache(e);
            listener(e);
        });
        return this;
    }
    /** Listen to channel created */
    onChannelCreated(listener) {
        this.on(constants_1.Events.ChannelCreated.toString(), async (e) => {
            this._updateCacheChannel(e);
            listener(e);
        });
        return this;
    }
    /** Listen to channel updated */
    onChannelUpdated(listener) {
        this.on(constants_1.Events.ChannelUpdated.toString(), async (e) => {
            if (e.channel_type === constants_1.ChannelType.CHANNEL_TYPE_THREAD &&
                e.status === 1) {
                const socket = this.socketManager.getSocket();
                await socket.joinChat(e.clan_id, e.channel_id, e.channel_type, false);
            }
            this._updateCacheChannel(e);
            listener(e);
        });
        return this;
    }
    /** Listen to channel deleted */
    onChannelDeleted(listener) {
        this.on(constants_1.Events.ChannelDeleted.toString(), async (e) => {
            const clan = this.clans.get(e.clan_id);
            if (!clan)
                return;
            this.channels.delete(e.channel_id);
            clan.channels.delete(e.channel_id);
            listener(e);
        });
        return this;
    }
    /** Listen to user send token to each other */
    onTokenSend(listener) {
        this.on(constants_1.Events.TokenSend.toString(), async (e) => {
            if (e.sender_id === this.clientId) {
                const clan = this.clans.get("0");
                const receiver = await (clan === null || clan === void 0 ? void 0 : clan.users.fetch(e.receiver_id));
                await (receiver === null || receiver === void 0 ? void 0 : receiver.sendDM({
                    t: `Funds Transferred: ${(+e.amount).toLocaleString()}â‚« | ${e.note}`,
                }, constants_1.TypeMessage.SendToken));
            }
            listener(e);
        });
        return this;
    }
    /** Listen to user react to messages on the channel, thread */
    onMessageReaction(listener) {
        this.on(constants_1.Events.MessageReaction.toString(), listener);
        return this;
    }
    /** Listen to user react to messages on the channel, thread */
    onUserChannelRemoved(listener) {
        this.on(constants_1.Events.UserChannelRemoved.toString(), listener);
        return this;
    }
    /** Listen to user leaved/removed in the channel */
    onUserClanRemoved(listener) {
        this.on(constants_1.Events.UserClanRemoved.toString(), async (e) => {
            const clan = this.clans.get(e.clan_id);
            if (!clan)
                return;
            e.user_ids.forEach((user_id) => {
                clan.users.delete(user_id);
            });
            listener(e);
        });
        return this;
    }
    /** Listen to user added in the channel */
    onUserChannelAdded(listener) {
        this.on(constants_1.Events.UserChannelAdded.toString(), async (e) => {
            var _a;
            const socket = this.socketManager.getSocket();
            if ((_a = e === null || e === void 0 ? void 0 : e.users) === null || _a === void 0 ? void 0 : _a.some((user) => user.user_id == this.clientId)) {
                await socket.joinChat(e.clan_id, e.channel_desc.channel_id, e.channel_desc.type, !e.channel_desc.channel_private);
            }
            listener(e);
        });
        return this;
    }
    /** Listen to users give coffee to each other */
    onGiveCoffee(listener) {
        this.on(constants_1.Events.GiveCoffee.toString(), listener);
        return this;
    }
    /** Listen to clan create new role */
    onRoleEvent(listener) {
        this.on(constants_1.Events.RoleEvent.toString(), listener);
        return this;
    }
    /** Listen to assigning a role to user */
    onRoleAssign(listener) {
        this.on(constants_1.Events.RoleAssign.toString(), listener);
        return this;
    }
    onNotification(listener) {
        this.on(constants_1.Events.Notifications.toString(), async (e) => {
            const notifications = e.notifications;
            if (notifications && notifications.length) {
                notifications.forEach(async (noti) => {
                    var _a;
                    const content = JSON.parse((_a = noti === null || noti === void 0 ? void 0 : noti.content) !== null && _a !== void 0 ? _a : {});
                    if (noti.code === -2) {
                        const session = this.sessionManager.getSession();
                        await this.apiClient.requestFriend(session.token, content.username, noti.sender_id);
                    }
                });
            }
            listener(e);
        });
        return this;
    }
    /** Listen to user added in CLAN */
    onAddClanUser(listener) {
        this.on(constants_1.Events.AddClanUser.toString(), async (e) => {
            var _a;
            if (e.user.user_id === this.clientId) {
                this.socketManager.getSocket().joinClanChat(e.clan_id);
                const clan = this.clans.get(e.clan_id);
                if (!clan) {
                    const clanObj = new Clan_1.Clan({
                        id: e.clan_id,
                        name: "unknown",
                        welcome_channel_id: "",
                    }, this, this.apiClient, this.socketManager, (_a = this.sessionManager.getSession()) === null || _a === void 0 ? void 0 : _a.token, this.messageQueue, this.messageDB);
                    await clanObj.loadChannels();
                    this.clans.set(e.clan_id, clanObj);
                }
            }
            else {
                const userRaw = {
                    id: e.user.user_id,
                    username: e.user.username,
                    clan_nick: "",
                    clan_avatar: "",
                    avartar: e.user.avatar,
                    display_name: e.user.display_name,
                    dmChannelId: "",
                };
                const clan = this.clans.get(e.clan_id);
                if (clan) {
                    const user = new User_1.User(userRaw, clan, this.messageQueue, this.socketManager, this.channelManager);
                    clan.users.set(e.user.user_id, user);
                }
                const clanDm = this.clans.get("0");
                if (clanDm) {
                    const user = new User_1.User(userRaw, clanDm, this.messageQueue, this.socketManager, this.channelManager);
                    clanDm.users.set(e.user.user_id, user);
                }
            }
            listener(e);
        });
        return this;
    }
    /** Listen to clan create a new event */
    onClanEventCreated(listener) {
        this.on(constants_1.Events.ClanEventCreated.toString(), listener);
        return this;
    }
    /** Listen to user lick a button on embed message */
    onMessageButtonClicked(listener) {
        this.on(constants_1.Events.MessageButtonClicked.toString(), listener);
        return this;
    }
    /** Listen to user joined a stream room */
    onStreamingJoinedEvent(listener) {
        this.on(constants_1.Events.StreamingJoinedEvent.toString(), listener);
        return this;
    }
    /** Listen to user leaved a stream room */
    onStreamingLeavedEvent(listener) {
        this.on(constants_1.Events.StreamingLeavedEvent.toString(), listener);
        return this;
    }
    /** Listen to user selected a input dropdown */
    onDropdownBoxSelected(listener) {
        this.on(constants_1.Events.DropdownBoxSelected.toString(), listener);
        return this;
    }
    /** Listen to user accepted call 1-1 */
    onWebrtcSignalingFwd(listener) {
        this.on(constants_1.Events.WebrtcSignalingFwd.toString(), listener);
        return this;
    }
    onVoiceStartedEvent(listener) {
        this.on(constants_1.Events.VoiceStartedEvent.toString(), listener);
        return this;
    }
    onVoiceEndedEvent(listener) {
        this.on(constants_1.Events.VoiceEndedEvent.toString(), listener);
        return this;
    }
    onVoiceJoinedEvent(listener) {
        this.on(constants_1.Events.VoiceJoinedEvent.toString(), listener);
        return this;
    }
    onVoiceLeavedEvent(listener) {
        this.on(constants_1.Events.VoiceLeavedEvent.toString(), listener);
        return this;
    }
    onQuickMenuEvent(listener) {
        this.on(constants_1.Events.QuickMenu.toString(), listener);
        return this;
    }
    closeSocket() {
        this.socketManager.closeSocket();
        this.eventManager = new event_manager_1.EventManager(); // Reset event manager
    }
    getListFriends(limit, state, cursor) {
        const session = this.sessionManager.getSession();
        return this.apiClient.getListFriends(session.token, limit, state, cursor);
    }
    acceptFriend(userId, username) {
        const session = this.sessionManager.getSession();
        return this.apiClient.requestFriend(session.token, username, userId);
    }
    addFriend(username) {
        const session = this.sessionManager.getSession();
        return this.apiClient.requestFriend(session.token, username);
    }
    async _fetchClanFromAPI(id) {
        throw Error(`Can not find clan ${id}!`);
    }
    async _fetchChannelFromAPI(id) {
        var _a;
        try {
            const session = this.sessionManager.getSession();
            const channelDetail = await this.apiClient.listChannelDetail(session.token, id);
            const clanId = (_a = channelDetail === null || channelDetail === void 0 ? void 0 : channelDetail.clan_id) !== null && _a !== void 0 ? _a : "0";
            const clan = this.clans.get(clanId);
            const channel = new TextChannel_1.TextChannel(channelDetail, clan, this.socketManager, this.messageQueue, this.messageDB);
            this.channels.set(channel.id, channel);
            clan === null || clan === void 0 ? void 0 : clan.channels.set(channel.id, channel);
            return channel;
        }
        catch (error) {
            throw Error(`Can not find channel ${id}!`);
        }
    }
    async _initChannelMessageCache(e) {
        const { clan_id, channel_id, sender_id, message_id, content, reactions, mentions, attachments, references, create_time_seconds, } = e;
        try {
            if (clan_id && clan_id !== "0") {
                const clan = this.clans.get(clan_id);
                await (clan === null || clan === void 0 ? void 0 : clan.loadChannels());
            }
            const channel = await this.channels.fetch(channel_id);
            const messageRaw = {
                id: message_id,
                clan_id: clan_id,
                channel_id: channel_id,
                sender_id: sender_id,
                content,
                reactions,
                mentions,
                attachments,
                references,
                create_time_seconds,
            };
            const message = new Message_1.Message(messageRaw, channel, this.socketManager, this.messageQueue);
            channel.messages.set(message_id, message);
            this.messageDB.saveMessage(e);
        }
        catch (error) {
            console.log("Error initChannelMessageCache");
        }
    }
    async _initUserClanCache(e) {
        var _a;
        const { clan_id, sender_id, username, clan_nick, clan_avatar, avatar, display_name, } = e;
        const clan = this.clans.get(clan_id !== null && clan_id !== void 0 ? clan_id : "0");
        if (clan) {
            const userCache = clan.users.get(sender_id);
            const clanDm = this.clans.get("0");
            const allDmChannels = this.channelManager.getAllDmChannels();
            if (!userCache && sender_id !== this.clientId && allDmChannels) {
                const userIds = Object.keys(allDmChannels !== null && allDmChannels !== void 0 ? allDmChannels : {}) || [];
                userIds.forEach((id) => {
                    var _a, _b, _c;
                    if (!id)
                        return;
                    const user = new User_1.User({ id, dmChannelId: (_a = allDmChannels === null || allDmChannels === void 0 ? void 0 : allDmChannels[id]) !== null && _a !== void 0 ? _a : "" }, clan, this.messageQueue, this.socketManager, this.channelManager);
                    const userDM = (_b = clanDm === null || clanDm === void 0 ? void 0 : clanDm.users) === null || _b === void 0 ? void 0 : _b.get(id);
                    if (!userDM) {
                        (_c = clanDm === null || clanDm === void 0 ? void 0 : clanDm.users) === null || _c === void 0 ? void 0 : _c.set(id, user);
                    }
                    const userClan = clan.users.get(id);
                    if (!userClan) {
                        clan.users.set(id, user);
                    }
                });
            }
            const userRaw = {
                id: sender_id,
                username: username,
                clan_nick: clan_nick,
                clan_avatar: clan_avatar,
                avartar: avatar,
                display_name: display_name,
                dmChannelId: (_a = allDmChannels === null || allDmChannels === void 0 ? void 0 : allDmChannels[sender_id]) !== null && _a !== void 0 ? _a : "",
            };
            const user = new User_1.User(userRaw, clan, this.messageQueue, this.socketManager, this.channelManager);
            clan.users.set(sender_id, user);
            clanDm === null || clanDm === void 0 ? void 0 : clanDm.users.set(sender_id, user);
        }
    }
    _updateCacheChannel(e) {
        const clan = this.clans.get(e.clan_id);
        if (!clan)
            return;
        const channelObj = new TextChannel_1.TextChannel(Object.assign(Object.assign({}, e), { type: e.channel_type, channel_private: e.channel_private ? 1 : 0 }), clan, this.socketManager, this.messageQueue, this.messageDB);
        this.channels.set(e.channel_id, channelObj);
        clan.channels.set(e.channel_id, channelObj);
        this.socketManager.getSocket().joinChat;
    }
}
exports.MezonClient = MezonClient;
//# sourceMappingURL=MezonClient.js.map