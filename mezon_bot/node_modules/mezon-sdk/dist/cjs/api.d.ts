import { ApiAuthenticateLogoutRequest, ApiAuthenticateRefreshRequest, ApiAuthenticateRequest, ApiChannelDescription, ApiClanDescList, ApiCreateChannelDescRequest, ApiQuickMenuAccessRequest, ApiRegisterStreamingChannelRequest, ApiSession, ApiUpdateMessageRequest, MezonUpdateRoleBody, TokenSentEvent } from "./interfaces";
export declare class MezonApi {
    readonly apiKey: string;
    readonly basePath: string;
    readonly timeoutMs: number;
    constructor(apiKey: string, basePath: string, timeoutMs: number);
    /** A healthcheck which load balancers can use to check the service. */
    mezonHealthcheck(bearerToken: string, options?: any): Promise<any>;
    /** A readycheck which load balancers can use to check the service. */
    mezonReadycheck(bearerToken: string, options?: any): Promise<any>;
    /** Authenticate a app with a token against the server. */
    mezonAuthenticate(basicAuthUsername: string, basicAuthPassword: string, body: ApiAuthenticateRequest, options?: any): Promise<ApiSession>;
    /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
    mezonAuthenticateLogout(bearerToken: string, body: ApiAuthenticateLogoutRequest, options?: any): Promise<any>;
    /** Create a new channel with the current user as the owner. */
    createChannelDesc(bearerToken: string, body: ApiCreateChannelDescRequest, options?: any): Promise<any>;
    /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
    mezonAuthenticateRefresh(basicAuthUsername: string, basicAuthPassword: string, body: ApiAuthenticateRefreshRequest, options?: any): Promise<ApiSession>;
    /** Deletes a message for an identity. */
    mezonDeleteMessage(bearerToken: string, id: string, options?: any): Promise<any>;
    /** Updates a message for an identity. */
    mezonUpdateMessage(bearerToken: string, id: string, body: ApiUpdateMessageRequest, options?: any): Promise<any>;
    /** List clans */
    listClanDescs(bearerToken: string, limit?: number, state?: number, cursor?: string, options?: any): Promise<ApiClanDescList>;
    /** List channels detail */
    listChannelDetail(bearerToken: string, channelId: string, options?: any): Promise<ApiChannelDescription>;
    buildFullUrl(basePath: string, fragment: string, queryParams: Map<string, any>): string;
    /** List channels */
    listChannelDescs(bearerToken: string, channel_type: number, clan_id?: string, limit?: number, state?: number, cursor?: string, options?: any): Promise<any>;
    /** List all users that are part of a channel. */
    listChannelVoiceUsers(bearerToken: string, clanId?: string, channelId?: string, channelType?: number, limit?: number, state?: number, cursor?: string, options?: any): Promise<any>;
    /** Register streaming in channel ( for bot - get streaming key) */
    registerStreamingChannel(bearerToken: string, body: ApiRegisterStreamingChannelRequest, options?: any): Promise<any>;
    sendToken(bearerToken: string, body: TokenSentEvent, options?: any): Promise<any>;
    updateRole(bearerToken: string, roleId: string, body: MezonUpdateRoleBody, options?: any): Promise<any>;
    listRoles(bearerToken: string, clanId?: string, limit?: string, state?: string, cursor?: string, options?: any): Promise<any>;
    getListFriends(bearerToken: string, limit?: number, state?: string, cursor?: string, options?: any): Promise<any>;
    requestFriend(bearerToken: string, usernames: string, ids?: string, options?: any): Promise<any>;
    /** list transaction detail */
    listTransactionDetail(bearerToken: string, transId: string, options?: any): Promise<any>;
    /**  */
    addQuickMenuAccess(bearerToken: string, body: ApiQuickMenuAccessRequest, options?: any): Promise<any>;
    /** deleteQuickMenuAccess */
    deleteQuickMenuAccess(bearerToken: string, botId?: string, options?: any): Promise<any>;
    playMedia(bearerToken: string, body: {
        room_name: string;
        participant_identity: string;
        participant_name: string;
        url: string;
        name: string;
    }, options?: any): Promise<any>;
}
