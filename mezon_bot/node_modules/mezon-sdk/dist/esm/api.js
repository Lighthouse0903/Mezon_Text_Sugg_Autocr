// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */
import { buildFetchOptions } from './utils';
import { encode } from 'js-base64';
import { sleep } from "./utils/helper";
export class MezonApi {
    apiKey;
    basePath;
    timeoutMs;
    constructor(apiKey, basePath, timeoutMs) {
        this.apiKey = apiKey;
        this.basePath = basePath;
        this.timeoutMs = timeoutMs;
    }
    /** A healthcheck which load balancers can use to check the service. */
    mezonHealthcheck(bearerToken, options = {}) {
        const urlPath = "/healthcheck";
        const queryParams = new Map();
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("GET", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** A readycheck which load balancers can use to check the service. */
    mezonReadycheck(bearerToken, options = {}) {
        const urlPath = "/readycheck";
        const queryParams = new Map();
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("GET", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** Authenticate a app with a token against the server. */
    mezonAuthenticate(basicAuthUsername, basicAuthPassword, body, options = {}) {
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/apps/authenticate/token";
        const queryParams = new Map();
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("POST", options, bodyJson);
        if (basicAuthUsername) {
            fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
    mezonAuthenticateLogout(bearerToken, body, options = {}) {
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/apps/authenticate/logout";
        const queryParams = new Map();
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("POST", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** Create a new channel with the current user as the owner. */
    createChannelDesc(bearerToken, body, options = {}) {
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/channeldesc";
        const queryParams = new Map();
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("POST", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
    mezonAuthenticateRefresh(basicAuthUsername, basicAuthPassword, body, options = {}) {
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/apps/authenticate/refresh";
        const queryParams = new Map();
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("POST", options, bodyJson);
        if (basicAuthUsername) {
            fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** Deletes a message for an identity. */
    mezonDeleteMessage(bearerToken, id, options = {}) {
        if (id === null || id === undefined) {
            throw new Error("'id' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/apps/message/{id}"
            .replace("{id}", encodeURIComponent(String(id)));
        const queryParams = new Map();
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** Updates a message for an identity. */
    mezonUpdateMessage(bearerToken, id, body, options = {}) {
        if (id === null || id === undefined) {
            throw new Error("'id' is a required parameter but is null or undefined.");
        }
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/apps/message/{id}"
            .replace("{id}", encodeURIComponent(String(id)));
        const queryParams = new Map();
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** List clans */
    listClanDescs(bearerToken, limit, state, cursor, options = {}) {
        const urlPath = "/v2/clandesc";
        const queryParams = new Map();
        queryParams.set("limit", limit);
        queryParams.set("state", state);
        queryParams.set("cursor", cursor);
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("GET", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** List channels detail */
    listChannelDetail(bearerToken, channelId, options = {}) {
        if (channelId === null || channelId === undefined) {
            throw new Error("'channelId' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/channeldesc/{channelId}".replace("{channelId}", encodeURIComponent(String(channelId)));
        const queryParams = new Map();
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("GET", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    buildFullUrl(basePath, fragment, queryParams) {
        let fullPath = basePath + fragment + "?";
        for (let [k, v] of queryParams) {
            if (v instanceof Array) {
                fullPath += v.reduce((prev, curr) => {
                    return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
                }, "");
            }
            else {
                if (v != null) {
                    fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
                }
            }
        }
        return fullPath;
    }
    /** List channels */
    listChannelDescs(bearerToken, channel_type, clan_id, limit, state, cursor, options = {}) {
        const urlPath = "/v2/channeldesc";
        const queryParams = new Map();
        queryParams.set("limit", limit);
        queryParams.set("state", state);
        queryParams.set("cursor", cursor);
        queryParams.set("channel_type", channel_type);
        if (clan_id) {
            queryParams.set("clan_id", clan_id);
        }
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("GET", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** List all users that are part of a channel. */
    listChannelVoiceUsers(bearerToken, clanId, channelId, channelType, limit, state, cursor, options = {}) {
        const urlPath = "/v2/channelvoice";
        const queryParams = new Map();
        queryParams.set("clan_id", clanId);
        queryParams.set("channel_id", channelId);
        queryParams.set("channel_type", channelType);
        queryParams.set("limit", limit);
        queryParams.set("state", state);
        queryParams.set("cursor", cursor);
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("GET", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** Register streaming in channel ( for bot - get streaming key) */
    registerStreamingChannel(bearerToken, body, options = {}) {
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/streaming-channels";
        const queryParams = new Map();
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("POST", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    async sendToken(bearerToken, body, options = {}) {
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        await sleep(200);
        const urlPath = "/v2/sendtoken";
        const queryParams = new Map();
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("POST", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    updateRole(bearerToken, roleId, body, options = {}) {
        if (roleId === null || roleId === undefined) {
            throw new Error("'roleId' is a required parameter but is null or undefined.");
        }
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/roles/{roleId}".replace("{roleId}", encodeURIComponent(String(roleId)));
        const queryParams = new Map();
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    listRoles(bearerToken, clanId, limit, state, cursor, options = {}) {
        const urlPath = "/v2/roles";
        const queryParams = new Map();
        queryParams.set("clan_id", clanId);
        queryParams.set("limit", limit);
        queryParams.set("state", state);
        queryParams.set("cursor", cursor);
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("GET", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    getListFriends(bearerToken, limit = 1000, state, cursor, options = {}) {
        const urlPath = "/v2/friend";
        const queryParams = new Map();
        queryParams.set("limit", limit);
        queryParams.set("state", state);
        queryParams.set("cursor", cursor);
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("GET", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    requestFriend(bearerToken, usernames, ids, options = {}) {
        const urlPath = "/v2/friend";
        const queryParams = new Map();
        queryParams.set("usernames", usernames);
        if (ids) {
            queryParams.set("ids", ids);
        }
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("POST", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** list transaction detail */
    listTransactionDetail(bearerToken, transId, options = {}) {
        if (transId === null || transId === undefined) {
            throw new Error("'transId' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/transaction/{transId}".replace("{transId}", encodeURIComponent(String(transId)));
        const queryParams = new Map();
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("GET", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /**  */
    addQuickMenuAccess(bearerToken, body, options = {}) {
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        const urlPath = "/v2/quickmenuaccess";
        const queryParams = new Map();
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("POST", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    /** deleteQuickMenuAccess */
    deleteQuickMenuAccess(bearerToken, botId, options = {}) {
        const urlPath = "/v2/quickmenuaccess";
        const queryParams = new Map();
        queryParams.set("botId", botId);
        let bodyJson = "";
        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
        const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(fullUrl, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
    playMedia(bearerToken, body, options = {}) {
        if (body === null || body === undefined) {
            throw new Error("'body' is a required parameter but is null or undefined.");
        }
        const urlPath = "https://stn.mezon.ai/api/playmedia";
        let bodyJson = "";
        bodyJson = JSON.stringify(body || {});
        const fetchOptions = buildFetchOptions("POST", options, bodyJson);
        if (bearerToken) {
            fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
        }
        return Promise.race([
            fetch(urlPath, fetchOptions).then((response) => {
                if (response.status == 204) {
                    return response;
                }
                else if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            }),
            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
        ]);
    }
}
//# sourceMappingURL=api.js.map