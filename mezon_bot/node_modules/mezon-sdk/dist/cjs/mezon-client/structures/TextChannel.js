"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextChannel = void 0;
const constants_1 = require("../../constants");
const helper_1 = require("../../utils/helper");
const CacheManager_1 = require("../utils/CacheManager");
const Message_1 = require("./Message");
class TextChannel {
    constructor(initChannelData, clan, socketManager, messageQueue, messageDB) {
        var _a, _b, _c, _d;
        this.id = initChannelData.channel_id;
        this.name = initChannelData.channel_label;
        this.channel_type = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.type;
        this.is_private = !!(initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.channel_private);
        this.category_id = (_a = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.category_id) !== null && _a !== void 0 ? _a : "";
        this.category_name = (_b = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.category_name) !== null && _b !== void 0 ? _b : "";
        this.parent_id = (_c = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.parent_id) !== null && _c !== void 0 ? _c : "";
        this.meeting_code = (_d = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.meeting_code) !== null && _d !== void 0 ? _d : "";
        this.clan = clan;
        this.messages = new CacheManager_1.CacheManager(async (message_id) => {
            const messageDb = this.messageDB.getMessageById(message_id, this.id);
            if (!messageDb) {
                throw Error(`Message ${message_id} not found on channel ${this.id}!`);
            }
            const newMessage = new Message_1.Message(messageDb, this, this.socketManager, this.messageQueue);
            return newMessage;
        }, 200);
        this.socketManager = socketManager;
        this.messageQueue = messageQueue;
        this.messageDB = messageDB;
    }
    async send(content, mentions, attachments, mention_everyone, anonymous_message, topic_id, code) {
        return this.messageQueue.enqueue(async () => {
            const dataSend = {
                clan_id: this.clan.id,
                channel_id: this.id,
                mode: (0, helper_1.convertChanneltypeToChannelMode)(this.channel_type),
                is_public: !this.is_private,
                content,
                mentions,
                attachments,
                anonymous_message,
                mention_everyone,
                code,
                topic_id,
            };
            return await this.socketManager.writeChatMessage(dataSend);
        });
    }
    async sendEphemeral(receiver_id, content, reference_message_id, mentions, attachments, mention_everyone, anonymous_message, topic_id, code = constants_1.TypeMessage.Ephemeral) {
        return this.messageQueue.enqueue(async () => {
            let references = [];
            if (reference_message_id) {
                let messageRef = await this.messages.fetch(reference_message_id);
                const user = await this.clan.users.fetch(messageRef.sender_id);
                references = [
                    {
                        message_ref_id: messageRef.id,
                        message_sender_id: messageRef.sender_id,
                        message_sender_username: user.clan_nick || user.display_name || user.username,
                        mesages_sender_avatar: user.clan_avatar || user.avartar,
                        content: JSON.stringify(messageRef.content),
                    },
                ];
            }
            const dataSend = {
                receiver_id,
                clan_id: this.clan.id,
                channel_id: this.id,
                mode: (0, helper_1.convertChanneltypeToChannelMode)(this.channel_type),
                is_public: !this.is_private,
                content,
                mentions,
                attachments,
                references: references !== null && references !== void 0 ? references : [],
                anonymous_message,
                mention_everyone,
                code,
                topic_id,
            };
            return await this.socketManager.writeEphemeralMessage(dataSend);
        });
    }
    async addQuickMenuAccess(body) {
        var _a, _b, _c;
        const id = (0, helper_1.generateSnowflakeId)();
        const bot_id = this.clan.getClientId();
        const payload = {
            channel_id: "0",
            clan_id: (_a = body === null || body === void 0 ? void 0 : body.clan_id) !== null && _a !== void 0 ? _a : "0",
            menu_type: (_b = body === null || body === void 0 ? void 0 : body.menu_type) !== null && _b !== void 0 ? _b : 1,
            action_msg: body.action_msg,
            background: (_c = body === null || body === void 0 ? void 0 : body.background) !== null && _c !== void 0 ? _c : "",
            menu_name: body.menu_name,
            id,
            bot_id,
        };
        try {
            return await this.clan.apiClient.addQuickMenuAccess(this.clan.sessionToken, payload);
        }
        catch (error) {
            throw error;
        }
    }
    async deleteQuickMenuAccess(botId) {
        const botIdPayload = botId !== null && botId !== void 0 ? botId : this.clan.getClientId();
        try {
            return await this.clan.apiClient.deleteQuickMenuAccess(this.clan.sessionToken, botIdPayload);
        }
        catch (error) {
            throw error;
        }
    }
    async playMedia(url, participantIdentity, participantName, name) {
        const meetingCode = this.meeting_code;
        if (!meetingCode) {
            return { error: "Channel not voice channel." };
        }
        const token = this.clan.sessionToken;
        if (!token) {
            return { error: "Token not found." };
        }
        const payload = {
            room_name: meetingCode,
            participant_identity: participantIdentity,
            participant_name: participantName,
            url: url,
            name: name,
        };
        try {
            return await this.clan.apiClient.playMedia(token, payload);
        }
        catch (error) {
            throw error;
        }
    }
}
exports.TextChannel = TextChannel;
//# sourceMappingURL=TextChannel.js.map