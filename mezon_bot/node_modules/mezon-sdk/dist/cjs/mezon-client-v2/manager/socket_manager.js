"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketManager = void 0;
const constants_1 = require("../../constants");
const socket_1 = require("../../socket");
const web_socket_adapter_pb_1 = require("../../web_socket_adapter_pb");
const Clan_1 = require("../structures/Clan");
class SocketManager {
    constructor(host, port, useSSL, adapter, sessionManager, apiClient, apiKey, eventManager, messageQueue, client) {
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.adapter = adapter;
        this.sessionManager = sessionManager;
        this.apiClient = apiClient;
        this.apiKey = apiKey;
        this.eventManager = eventManager;
        this.messageQueue = messageQueue;
        this.client = client;
        this.socket = new socket_1.DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    createSocket() {
        this.adapter = new web_socket_adapter_pb_1.WebSocketAdapterPb();
        this.socket = new socket_1.DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    getSocket() {
        return this.socket;
    }
    async connect(sockSession) {
        const session = await this.socket.connect(sockSession, true);
        this.isHardDisconnect = false;
        return session;
    }
    closeSocket() {
        this.isHardDisconnect = true;
        this.socket.close();
        console.log("eventManager", this.eventManager);
    }
    isOpen() {
        return this.socket.isOpen();
    }
    async onerror(evt) {
        console.log("onerror", evt);
        if (this.isHardDisconnect)
            return;
        if (this.socket.isOpen()) {
            await this.retriesConnect();
        }
    }
    onheartbeattimeout() {
        console.log("Heartbeat timeout.");
    }
    ondisconnect(e) {
        console.log("Disconnected!", e === null || e === void 0 ? void 0 : e.reason);
        if (this.isHardDisconnect)
            return;
        this.retriesConnect();
    }
    async connectSocket(sessionToken) {
        var _a;
        const clans = await this.apiClient.listClanDescs(sessionToken);
        (_a = clans.clandesc) === null || _a === void 0 ? void 0 : _a.forEach(async (clan) => {
            var _a;
            await this.socket.joinClanChat(clan.clan_id || "");
            if (!this.client.clans.get(clan.clan_id)) {
                const clanObj = new Clan_1.Clan({
                    id: clan.clan_id,
                    name: (_a = clan === null || clan === void 0 ? void 0 : clan.clan_name) !== null && _a !== void 0 ? _a : "unknown",
                }, this.client, this.apiClient, this, sessionToken, this.messageQueue);
                this.client.clans.set(clan.clan_id, clanObj);
            }
        });
        // join direct message
        await this.socket.joinClanChat("0");
        ["ondisconnect", "onerror", "onheartbeattimeout"].forEach((event) => {
            this.socket[event] = this[event].bind(this);
        });
        for (const event in constants_1.Events) {
            const key = constants_1.Events[event].toString();
            this.socket.socketEvents.on(key, (...args) => {
                this.client.emit(key, ...args);
            });
        }
    }
    async retriesConnect() {
        let retryInterval = 5000;
        const maxRetryInterval = 60000;
        console.log("Reconnecting...");
        const interval = setInterval(async () => {
            try {
                this.createSocket();
                const sockSession = await this.sessionManager.authenticate(this.apiKey);
                const sessionConnected = await this.connect(sockSession);
                if (sessionConnected === null || sessionConnected === void 0 ? void 0 : sessionConnected.token) {
                    await this.connectSocket(sessionConnected.token);
                }
                console.log("Connected successfully!");
                clearInterval(interval);
            }
            catch (e) {
                console.log("Connection failed:", e);
                retryInterval = Math.min(retryInterval * 2, maxRetryInterval);
                console.log(`Retrying in ${retryInterval / 1000} seconds...`);
                clearInterval(interval);
                setTimeout(() => this.retriesConnect(), retryInterval);
            }
        }, retryInterval);
    }
    async writeChatMessage(dataWriteMessage) {
        var _a, _b, _c;
        try {
            const msgACK = await this.socket.writeChatMessage(dataWriteMessage.clan_id, dataWriteMessage.channel_id, dataWriteMessage.mode, dataWriteMessage.is_public, dataWriteMessage.content, (_a = dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.mentions) !== null && _a !== void 0 ? _a : [], (_b = dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.attachments) !== null && _b !== void 0 ? _b : [], (_c = dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.references) !== null && _c !== void 0 ? _c : [], dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.anonymous_message, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.mention_everyone, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.avatar, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.code, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.topic_id);
            return msgACK;
        }
        catch (error) {
            console.log("Error writeChatMessage", error);
            throw error;
        }
    }
    async updateChatMessage(dataUpdateMessage) {
        var _a, _b, _c;
        try {
            const msgACK = await this.socket.updateChatMessage(dataUpdateMessage.clan_id, dataUpdateMessage.channel_id, dataUpdateMessage.mode, dataUpdateMessage.is_public, dataUpdateMessage.message_id, dataUpdateMessage.content, (_a = dataUpdateMessage === null || dataUpdateMessage === void 0 ? void 0 : dataUpdateMessage.mentions) !== null && _a !== void 0 ? _a : [], (_b = dataUpdateMessage === null || dataUpdateMessage === void 0 ? void 0 : dataUpdateMessage.attachments) !== null && _b !== void 0 ? _b : [], (_c = dataUpdateMessage === null || dataUpdateMessage === void 0 ? void 0 : dataUpdateMessage.hideEditted) !== null && _c !== void 0 ? _c : false, dataUpdateMessage === null || dataUpdateMessage === void 0 ? void 0 : dataUpdateMessage.topic_id);
            return msgACK;
        }
        catch (error) {
            console.log("Error updateChatMessage", error);
            throw error;
        }
    }
    async writeMessageReaction(dataReactionMessage) {
        var _a, _b;
        try {
            const msgACK = await this.socket.writeMessageReaction((_a = dataReactionMessage.id) !== null && _a !== void 0 ? _a : "", dataReactionMessage.clan_id, dataReactionMessage.channel_id, dataReactionMessage.mode, dataReactionMessage.is_public, dataReactionMessage.message_id, dataReactionMessage.emoji_id, dataReactionMessage.emoji, dataReactionMessage.count, dataReactionMessage.message_sender_id, (_b = dataReactionMessage === null || dataReactionMessage === void 0 ? void 0 : dataReactionMessage.action_delete) !== null && _b !== void 0 ? _b : false);
            return msgACK;
        }
        catch (error) {
            console.log("Error writeMessageReaction", error);
            throw error;
        }
    }
    async removeChatMessage(dataRemoveMessage) {
        try {
            const msgACK = await this.socket.removeChatMessage(dataRemoveMessage.clan_id, dataRemoveMessage.channel_id, dataRemoveMessage.mode, dataRemoveMessage.is_public, dataRemoveMessage.message_id);
            return msgACK;
        }
        catch (error) {
            console.log("Error removeChatMessage", error);
            throw error;
        }
    }
}
exports.SocketManager = SocketManager;
//# sourceMappingURL=socket_manager.js.map