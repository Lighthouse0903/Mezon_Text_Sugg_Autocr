"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MezonClient = void 0;
const api_1 = require("../api");
// import { Session } from "./session";
// import { DefaultSocket } from "./socket";
// import { WebSocketAdapter } from "./web_socket_adapter";
const web_socket_adapter_pb_1 = require("../web_socket_adapter_pb");
const socket_manager_1 = require("./socket_manager");
const message_manager_1 = require("./message_manager");
const channel_manager_1 = require("./channel_manager");
const session_manager_1 = require("./session_manager");
const event_manager_1 = require("./event_manager");
const DEFAULT_HOST = "api.mezon.vn";
const DEFAULT_PORT = "443";
const DEFAULT_API_KEY = "";
const DEFAULT_SSL = true;
const DEFAULT_TIMEOUT_MS = 7000;
class MezonClient {
    constructor(apiKey = DEFAULT_API_KEY, host = DEFAULT_HOST, port = DEFAULT_PORT, useSSL = DEFAULT_SSL, timeout = DEFAULT_TIMEOUT_MS) {
        this.apiKey = apiKey;
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.timeout = timeout;
        const scheme = useSSL ? "https://" : "http://";
        const basePath = `${scheme}${host}:${port}`;
        this.apiClient = new api_1.MezonApi(apiKey, basePath, timeout);
        this.sessionManager = new session_manager_1.SessionManager(this.apiClient);
        this.eventManager = new event_manager_1.EventManager();
        this.socketManager = new socket_manager_1.SocketManager(this.host, this.port, this.useSSL, new web_socket_adapter_pb_1.WebSocketAdapterPb(), this.sessionManager, this.apiClient, this.apiKey, this.eventManager);
        this.messageManager = new message_manager_1.MessageManager(this.socketManager);
        this.channelManager = new channel_manager_1.ChannelManager(this.apiClient, this.socketManager, this.sessionManager);
    }
    async authenticate() {
        const sockSession = await this.sessionManager.authenticate(this.apiKey);
        const sessionConnected = await this.socketManager.connect(sockSession);
        if (sessionConnected === null || sessionConnected === void 0 ? void 0 : sessionConnected.token) {
            await this.socketManager.connectSocket(sessionConnected.token);
        }
        return "Authenticate success!";
    }
    on(event, func, context = null) {
        this.eventManager.on(event, func, context);
    }
    remove(event, func) {
        this.eventManager.remove(event, func);
    }
    closeSocket() {
        this.socketManager.closeSocket();
        this.eventManager = new event_manager_1.EventManager(); // Reset event manager
    }
    async logout() {
        return this.sessionManager.logout();
    }
    /** Send message in channel/thread */
    async sendMessage(clan_id, channel_id, mode, is_public, msg, mentions, attachments, ref, anonymous_message, mention_everyone, avatar, code, topic_id) {
        return await this.messageManager.sendMessage(clan_id, channel_id, mode, is_public, msg, mentions, attachments, ref, anonymous_message, mention_everyone, avatar, code, topic_id);
    }
    /** Send DM message */
    async sendDMChannelMessage(channelDmId, msg, messOptions = {}, attachments = [], refs = [], code) {
        return await this.messageManager.sendDMChannelMessage(channelDmId, msg, messOptions, attachments, refs, code);
    }
    /** Update message */
    async updateChatMessage(clan_id, channel_id, mode, is_public, message_id, content, mentions, attachments, hideEditted) {
        return await this.messageManager.updateChatMessage(clan_id, channel_id, mode, is_public, message_id, content, mentions, attachments, hideEditted);
    }
    /** Create DM channel */
    async createDMchannel(userId) {
        return this.channelManager.createDMchannel(userId);
    }
    /** List current user in channel voice */
    async listChannelVoiceUsers(clanId, channelId, channelType, limit = 500, state, cursor) {
        return await this.channelManager.listChannelVoiceUsers(clanId, channelId, channelType, limit, state, cursor);
    }
    /** Send token to user */
    async sendToken(sendTokenData) {
        const session = this.sessionManager.getSession();
        return this.apiClient.sendToken(session.token, sendTokenData);
    }
    /** React message */
    async reactionMessage(id, clan_id, channel_id, mode, is_public, message_id, emoji_id, emoji, count, message_sender_id, action_delete) {
        return await this.messageManager.reactionMessage(id, clan_id, channel_id, mode, is_public, message_id, emoji_id, emoji, count, message_sender_id, action_delete);
    }
}
exports.MezonClient = MezonClient;
//# sourceMappingURL=mezon_client.js.map